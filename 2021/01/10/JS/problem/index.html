<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常见问题 | 小燕子的窝</title><meta name="author" content="yanrongdeng"><meta name="copyright" content="yanrongdeng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="柯里化函数 call() 和 apply() 、bind() 的区别实际上，apply 和 call 的功能是一样的，只是传入的参数列表形式不同。apply：最多只能有两个参数——新 this 对象和一个数组 argArray。参考：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lengyuehuahun&#x2F;p&#x2F;5643625.html 深拷贝和浅拷贝的区别参考：https:&#x2F;&#x2F;www.cnblo">
<meta property="og:type" content="article">
<meta property="og:title" content="常见问题">
<meta property="og:url" content="http://example.com/2021/01/10/JS/problem/index.html">
<meta property="og:site_name" content="小燕子的窝">
<meta property="og:description" content="柯里化函数 call() 和 apply() 、bind() 的区别实际上，apply 和 call 的功能是一样的，只是传入的参数列表形式不同。apply：最多只能有两个参数——新 this 对象和一个数组 argArray。参考：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lengyuehuahun&#x2F;p&#x2F;5643625.html 深拷贝和浅拷贝的区别参考：https:&#x2F;&#x2F;www.cnblo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-01-10T05:10:38.000Z">
<meta property="article:modified_time" content="2022-03-14T10:29:59.821Z">
<meta property="article:author" content="yanrongdeng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/01/10/JS/problem/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常见问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-14 18:29:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归纳</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小燕子的窝</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归纳</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常见问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-10T05:10:38.000Z" title="发表于 2021-01-10 13:10:38">2021-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-14T10:29:59.821Z" title="更新于 2022-03-14 18:29:59">2022-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/">小知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p><img src="https://img-blog.csdnimg.cn/b150d0f7f33c41bb9af33f1be387b9a8.png" alt="在这里插入图片描述"></p>
<h3 id="call-和-apply-、bind-的区别"><a href="#call-和-apply-、bind-的区别" class="headerlink" title="call() 和 apply() 、bind() 的区别"></a>call() 和 apply() 、bind() 的区别</h3><p>实际上，apply 和 call 的功能是一样的，只是传入的参数列表形式不同。<br>apply：最多只能有两个参数——新 this 对象和一个数组 argArray。<br>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lengyuehuahun/p/5643625.html">https://www.cnblogs.com/lengyuehuahun/p/5643625.html</a></p>
<h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/echolun/p/7889848.html">https://www.cnblogs.com/echolun/p/7889848.html</a></p>
<p><strong>深拷贝本身只针对较为复杂的 object 类型数据</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> brr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr)); </span><br><span class="line"><span class="keyword">let</span> crr = $.extend(<span class="literal">true</span>,[],arr); <span class="comment">//jQuery的方法，第一个参数为 true表示深拷贝  false表示浅拷贝</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr,brr,crr);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>一维数组深拷贝的方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> brr = [...arr];  </span><br><span class="line">    brr.push(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> crr = brr.concat(); </span><br><span class="line">    crr.push(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> drr = crr.slice(<span class="number">0</span>);  </span><br><span class="line">    drr.push(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> err = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(drr)) </span><br><span class="line">    err.push(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr,brr,crr,drr,err)</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">(<span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] (<span class="number">4</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] (<span class="number">5</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] (<span class="number">6</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] (<span class="number">7</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="JSON-parse-JSON-stringify-obj-这种方案的弊端"><a href="#JSON-parse-JSON-stringify-obj-这种方案的弊端" class="headerlink" title="JSON.parse(JSON.stringify(obj)) 这种方案的弊端"></a>JSON.parse(JSON.stringify(obj)) 这种方案的弊端</h4><ol>
<li><p>如果json里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj.date); <span class="comment">// object</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> objCopy.date); <span class="comment">// string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; {}；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">reg</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\w+&#x27;</span>),</span><br><span class="line">        <span class="attr">err</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">hh</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">hh</span>: <span class="literal">NaN</span>,</span><br><span class="line">        <span class="attr">isInfinite</span>: <span class="number">1.7976931348623157E+10308</span>,</span><br><span class="line">        <span class="attr">minusInfinity</span>: -<span class="number">1.7976931348623157E+10308</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">p1</span>: <span class="keyword">new</span> Person(<span class="string">&#x27;lxcan&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">    <span class="built_in">console</span>.log(obj.p1.__proto__.constructor === Person); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(objCopy.p1.__proto__.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果对象中存在循环引用的情况也无法实现深拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line">    obj.obj = obj;</span><br><span class="line">    <span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;objCopy&#x27;</span>, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上，如果拷贝的对象不涉及上面的情况，可以使用 JSON.parse(JSON.stringify(obj)) 实现深拷贝。</p>
<h3 id="一个页面从输入-URL到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL到页面加载显示完成，这个过程中都发生了什么？</h3><p> 分为4个步骤：<br> （1）当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在<strong>远程DNS服务器</strong>上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。<br> （2） 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br> （3）一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。<br> （4）此时， Web 服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了我们关注的前端模块 。简单来说，浏览器会解析 HTML 生成 DOM Tree ，其次会根据CSS生成CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<p>简述：</p>
<ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li>
<li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP/IP 连接;</li>
<li>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。</li>
<li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li>
<li>释放 TCP/IP 连接;</li>
<li>浏览器将该 html 文本并显示内容; </li>
</ol>
<h3 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h3><blockquote>
<p>也就是通过new创建一个对象的时候，构造函数内部有哪些改变？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.friend = [];</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person();</span><br><span class="line">a.friend[<span class="number">0</span>] = <span class="string">&#x27;王琦&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(b.friend);<span class="comment">//Array [ &quot;王琦&quot; ]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ul>
<h3 id="http2-0-3-0的区别"><a href="#http2-0-3-0的区别" class="headerlink" title="http2.0 3.0的区别"></a>http2.0 3.0的区别</h3><blockquote>
<p>截止到现在，IETF已经发布了5个HTTP协议了，包括HTTP0.9、HTTP1.0、HTTP1.1、HTTP2、HTTP3.下面讲一下各个版本的区别：</p>
</blockquote>
<p><strong>HTTP0.9</strong></p>
<p>1991年发布， 没有header，功能非常简单，只支持GET。</p>
<p><strong>HTTP1.0</strong></p>
<p>1996年发布，明文传输安全性差，header特别大​。它相对​0.9有以下增强：</p>
<p>增加了header（使用元数据与数据解耦）<br>增加了status code，​用于声明请求的结果。<br>content-type可以传输其它文件。<br>请求头增加了http/1.0版本号。<br>缺点：每请求一次资源就新建一次tcp连接</p>
<p><strong>HTTP1.1</strong></p>
<p>1997发布，是现在使用最广泛的版本。它相对1.0有以下增强​：</p>
<p>可以设置keepalive让http重用tcp连接（请求必需串行发送）<br>支持pipeline传输，请求发出后可以继续发送请求<br>增加了HOST头，让服务端知道用户请求的是哪个域名<br>增加了type、language、encoding等header<br>2014年更新了内容：</p>
<p>增加了TLS支持,即https传输<br>支持四种模型： 短连接，可重用tcp的长链接，服务端push模型（服务端主动将数据推送到客户端cache中），websocket模型<br>缺点：还是文本协议，客户端服务端都需要利用cpu解压缩</p>
<p><strong>HTTP2</strong></p>
<p>2015年发布，主要是提升安全性与性能。它相对​1.1的增强有：</p>
<p>头部压缩（合并同时发出请求的相同部分）<br>二进制分帧传输，更方便头部只传输差异部分<br>流多路复用，同一服务下只需要用一个连接，节省了连接<br>服务器推送，一次客户端请求服务端可以多次响应。<br>可以在一个tcp连接中并发发送请求<br>缺点：基于tcp传输，会有队头阻塞问题（丢包停止窗口滑动），tcp会丢包重传。tcp握手延时长，协议僵化问题。</p>
<p><strong>HTTP3</strong></p>
<p>2018年发布，基于谷歌的QUIC，底层使用udp代码tcp协议，</p>
<p>这样解决了队头阻塞问题，同样无需握手,性能大大地提升，默认使用tls加密​。<br><img src="https://img-blog.csdnimg.cn/2462d1af5f2c45fba4dbb117dd9b928e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="简述https原理，以及与http的区别-http协议的原理"><a href="#简述https原理，以及与http的区别-http协议的原理" class="headerlink" title="简述https原理，以及与http的区别 http协议的原理"></a>简述https原理，以及与http的区别 http协议的原理</h3><p>http协议是基于TCP/IP协议之上的应用层协议。<br>https工作原理<br>(1)客户端发送请求到服务器端<br>(2)服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在<br>(3)客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端<br>(4)服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端<br>(5)客户端使用共享密钥解密数据<br>(6)SSL加密建立</p>
<h3 id="https的过程"><a href="#https的过程" class="headerlink" title="https的过程"></a>https的过程</h3><ol>
<li><p>客户端发送HTTPS请求<br>在浏览器上输入一个https的网址，然后连接到服务端的443端口。过程中，客户端会发送一个密文簇给服务器，包含了客户端支持的加密算法清单<br>客户端告诉服务器，我这里支持哪些加密算法</p>
</li>
<li><p>服务端配置<br>采用HTTPS协议的服务器必须要有一套数字证书（可以直接制作，也可以向组织申请）<br>这套证书其实就是一对公钥和私钥<br>公钥：就是一把锁头<br>私钥：就是一把钥匙<br>公钥用于给信息加锁，而只有持有这把锁密钥（钥匙）的才可以看到里面的内容</p>
</li>
<li><p>传送证书<br>服务端将证书传给客户端<br>证书中包含了：公钥，证书的机构信息、过期信息……</p>
</li>
<li><p>客户端解析证书<br>验证证书是否有效(这部分的工作由客户端的TSL完成)<br>无效：弹出警告框<br>有效：生成一段随机数，用公钥进行加密(加密的随机数用于握手)</p>
</li>
<li><p>传送加密信息<br>将加密后的随机数发送给服务端</p>
</li>
<li><p>服务端解密<br>服务端利用私钥解密，得到那个随机数</p>
</li>
</ol>
<p>————————–非对称加密结束—————————-<br>服务端利用这个随机数对待传输的信息进程对称加密</p>
<ol start="7">
<li><p>传输加密后的信息<br>这部分是服务端利用随机数对信息进行的加密，可以在客户端解密</p>
</li>
<li><p>客户端解密信息<br>客户端利用之前生成的随机数解密服务端发送过来的信息，于是获取了解密后的内容</p>
</li>
</ol>
<p>————————–对称加密结束—————————-</p>
<h3 id="讲一下Http缓存策略"><a href="#讲一下Http缓存策略" class="headerlink" title="讲一下Http缓存策略"></a>讲一下Http缓存策略</h3><p>Http 的缓存主要利用 header 里的两个字段来控制：</p>
<p>Cache-control主要包含以及几个字段：<br>private:则只有客户端可以缓存<br>public:客户端和代理服务器都可以缓存<br>max-age:缓存的过期时间<br>no-cache:需要使用对比缓存来验证缓存数据<br>no-store:所有内存都不会进行缓存<br>ETag(Entity Tag):即用来进行对比缓存，Etag 是服务端资源的一个标识码</p>
<p>当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回 304。</p>
<p>通过 Cache-control 和 Etag 的配合来实现 Http 的缓存机制。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6888875643266662414">详情：https://juejin.cn/post/6888875643266662414</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hhthwx/article/details/80152728">详情：https://blog.csdn.net/hhthwx/article/details/80152728</a></p>
<h3 id="如何给-localStorage-加上-max-age-功能"><a href="#如何给-localStorage-加上-max-age-功能" class="headerlink" title="如何给 localStorage 加上 max-age 功能"></a>如何给 localStorage 加上 max-age 功能</h3><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h3 id="Http与Https的基本概念和他们的区别"><a href="#Http与Https的基本概念和他们的区别" class="headerlink" title="Http与Https的基本概念和他们的区别"></a>Http与Https的基本概念和他们的区别</h3><p>http的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作,是专门用来传输注入HTML的超媒体文档等web内容的协议,它是基于传输层的TCP协议的应用层协议</p>
<p>https:https是基于安全套接字的http协议,也可以理解为是http+ssl/tls(数字证书)的组合</p>
<h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别:"></a>http和https的区别:</h4><p>HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头<br>HTTP 是不安全的，而 HTTPS 是安全的<br>HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443<br>在 OSI 网络模型中，HTTPS的加密是在传输层完成的,因为SSL是位于传输层的,TLS的前身是SSL,所以同理<br>HTTP无需认证证书,而https需要认证证书<br>小结：简单来说http是用来进行html等超媒体传输的,但是http不安全,为了安全,使用证书SSL和HTTP的方式进行数据传输,也就是HTTPS </p>
<h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><p>首先服务端给客户端传输证书,这个证书就是公钥,只是包含了很多的信息,比如说证书的办法机构,证书的过期时间<br>客户端进行证书的解析,比如说验证办法机构,过期时间,如果发现没有任何问题,就生成一个随机值(私钥),然后用证书对这个私钥进行加密,并发送给服务端<br>服务端使用私钥将这个信息进行解密,得到客户端的私钥,然后客户端和服务端就可以通过这个私钥进行通信了<br>服务端将消息进行对称加密(简单来说就是讲消息和私钥进行混合,除非知道私钥否则服务进行解密),私钥正好只有客户端和服务端知道,所以信息就比较安全了<br>服务端将进行对称加密后的消息进行传送<br>客户端使用私钥进行信息的解密<br>小结：https就是使用了非对称加密(一对公私钥进行加密解密)进行公钥传输,然后客户端通过公钥加密将自己的私钥发给服务端,以后就可以使用这个私钥进行消息的收发了(图文方式的https的加密原理,可以点击链接:到我的另一篇博客进行学习)</p>
<h3 id="常用的HTTP方法有哪些"><a href="#常用的HTTP方法有哪些" class="headerlink" title="常用的HTTP方法有哪些"></a>常用的HTTP方法有哪些</h3><p>GET 从服务器获得资源</p>
<p>POST 客户端向服务器提交资源</p>
<p>PUT 修改服务器相关资源  (已经很少用)</p>
<p>DELETE 删除服务器相关资源   (已经很少用)</p>
<p>小结：我基本用的是get和post,其余的两个基本没用过(被自己菜醒)</p>
<h3 id="GET方法与POST方法的区别-什么时候应该使用GET什么时候应该使用POST"><a href="#GET方法与POST方法的区别-什么时候应该使用GET什么时候应该使用POST" class="headerlink" title="GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST"></a>GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息数量没有限制<br>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。<br>小结：对于信息的获取一般使用get,在以下情况下最好使用post请求:</p>
<p>向服务器发送大量数据（因为post没有发送数据的数量限制）<br>无法使用缓存文件（会更新服务器上的文件）<br>发送包含未知字符的用户输入时(亲身经历过GET的坑,泪目) </p>
<h3 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h3><p>这里我推荐一位大神写的很出色的博客,在这里就不详细写了,博客地址:<a target="_blank" rel="noopener" href="https://blog.csdn.net/a19881029/article/details/14002273">https://blog.csdn.net/a19881029/article/details/14002273</a></p>
<p>小结：主要的区别就是请求报文有url和请求方法,响应报文没有这两个,但是有状态码和状态码描述,还要注意一些常见的请求头和响应头代表的意思,比如说Connection:Keep-Alive</p>
<h3 id="HTTP1-0-1-1-2-0之间的区别和特性"><a href="#HTTP1-0-1-1-2-0之间的区别和特性" class="headerlink" title="HTTP1.0,1.1,2.0之间的区别和特性"></a>HTTP1.0,1.1,2.0之间的区别和特性</h3><p>http1.0:</p>
<p>是一种无状态、无连接的应用层协议,每个请求都会新创建一个tcp连接,完成后关闭服务端不跟踪也不记录过去的请求(无状态),但正因频繁创建连接,由于tcp的慢启动(为了不给网络造成拥堵,在首次进行tcp请求的时候,会限制服务端和客户端之间交互数据量的上限,大概为14kb,之后以指数级增长),服务端接受请求,处理完,发送完响应之后就会将tcp连接关闭,这造成了很大的资源浪费,而且http1.0在一个请求接收到响应之后才会接着发送下一个,这也造成了head of line blocking(队头阻塞),现在的浏览器为了解决这个问题,采用了一个页面可以建立多个tcp连接的方式来进行</p>
<p>http1.1:</p>
<p>继承了http1.0的特点,同时改善了http的一些问题,首先是长连接,http1.1新增加了connecion字段,里面可以设置keey-Alive(保持连接)或者close(关闭长连接),避免了每次请求都会新建连接,提高了网络的利用率<br>http1.1还增加了Host字段,用来明确表示浏览器要服务器上的哪一个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点,同时还支持了断点续传<br>http1.1的管道:可以发送很多请求到服务端,但是服务端必须要按顺序返回响应,由此可以看出http1.1的管道只是把客户端的请求序列变成了服务端的响应序列,还是有问题,很多浏览器并不是很支持<br>http1.1还增加了缓存,断点续传</p>
<p>http2.0 : </p>
<p>采用了二进制分帧(frame),在应用层和传输层之间增加了一个二进制分帧层,也就是把http1.x的header和body使用帧(frame)进行了封装<br>这里明确几个概念:流(stream) : 已经建立上连接的双向字节流(也就是一个请求和其对应的响应) 消息:与逻辑消息对应的完整的一系列数据帧 帧(frame):http2.0进行通信的最小单位,每个帧都会包含一个头部,这个头部会包含当前帧所处的流<br>多路复用:所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流,每个数据流都以消息的方式进行发送,这个发送可以使乱序的,然后在通过每个帧头部的流标识符进行组装,同时每个数据流都可以设置优先级,可见http2.0真正实现了并行发送数据,这个是给予二进制分帧来实现的,接下来上一张图片,展示一下一个在一个流中分帧传输的实例</p>
<p>头部压缩:就是和服务端约定头部的数据的编码,来将头部进行压缩后发送,这样就可以增加请求头的容量</p>
<p>小结：这里讲的稍微有一点多,这里给一个总结</p>
<p>http1.0:无连接,无状态,一次请求一个tcp连接<br>http1.1:持久连接,请求管道化(有一些缺陷) ,增加了host字段,缓存,断点续传<br>http2.0 : 二进制分帧(多路复用的实现基础), 多路复用,头部压缩</p>
<h3 id="常见HTTP首部字段"><a href="#常见HTTP首部字段" class="headerlink" title="常见HTTP首部字段"></a>常见HTTP首部字段</h3><p>这里我还是给大家推荐两篇博客,写的很详细就不在这里献丑了</p>
<p> 地址1 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenxizhaolu/p/7591549.html">https://www.cnblogs.com/chenxizhaolu/p/7591549.html</a></p>
<p> 地址2 : <a target="_blank" rel="noopener" href="https://blog.csdn.net/chenyuanyong110/article/details/52781462">https://blog.csdn.net/chenyuanyong110/article/details/52781462</a></p>
<h3 id="HTTP的缺点与HTTPS有哪些改进"><a href="#HTTP的缺点与HTTPS有哪些改进" class="headerlink" title="HTTP的缺点与HTTPS有哪些改进"></a>HTTP的缺点与HTTPS有哪些改进</h3><p>http的传输是不安全的,https是http+ssl证书进行加密的,所以比http安全(这里的详细过程上面有写)</p>
<h4 id="HTTP优化"><a href="#HTTP优化" class="headerlink" title="HTTP优化"></a>HTTP优化</h4><p>资源内敛 : 资源内联 : 既然每个资源的首次访问都会存在握手等rtt损耗,那么越少数量的资源请求就越好,例如咋一个html中src访问css,不如直接将其这个css集成到html中<br>图片懒加载 ; 用到的时候在加载,这个已经很普遍了,就不细说了<br>服务器渲染 : 让服务端先将页面渲染好,在发送给客户端,也可以减少rtt的次数</p>
<h3 id="为什么HTTPS安全"><a href="#为什么HTTPS安全" class="headerlink" title="为什么HTTPS安全"></a>为什么HTTPS安全</h3><p>HTTPS是HTTP和SSL组合而成的,在传输层使用了SSL进行加密,保证了只有拥有私钥的才能看到信</p>
<h3 id="请指出-onload-和-ready-两个事件的区别"><a href="#请指出-onload-和-ready-两个事件的区别" class="headerlink" title="请指出 onload 和 ready 两个事件的区别"></a>请指出 onload 和 ready 两个事件的区别</h3><p>页面加载完成有两种事件</p>
<p>一是 <code>$(document).ready(function()&#123;&#125;)</code>(简写<code>$(function()&#123;&#125;)</code>)，表示文档结构DOM已经加载完成（不包含图片等非文字媒体文件）<br>二是 <code>window.onload = function()&#123;&#125;</code>，指示页面包含图片等文件在内的所有元素都加载完成。</p>
<!-- ## 各种概念/原理 -->

<h3 id="什么是事件代理-事件委托？"><a href="#什么是事件代理-事件委托？" class="headerlink" title="什么是事件代理/事件委托？"></a>什么是事件代理/事件委托？</h3><p>事件代理/事件委托是<strong>利用冒泡事件/捕获事件的原理，子元素触发的事件，由父元素完成</strong>，可以非常方便的提高程序性能，减小内存空间。</p>
<blockquote>
<p>事件委托应用场景，e.target 和 e.currentTarget 区别</p>
</blockquote>
<h3 id="什么是事件冒泡？什么是事件捕获？"><a href="#什么是事件冒泡？什么是事件捕获？" class="headerlink" title="什么是事件冒泡？什么是事件捕获？"></a>什么是事件冒泡？什么是事件捕获？</h3><p><strong>冒泡型事件</strong>：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 <strong>从内到外(从子集到父级)</strong></p>
<p><strong>捕获型事件</strong>：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 <strong>从外到内 (从父级到子集)</strong></p>
<p>一般用 <code>dom.addEventListener(&#39;click&#39;,fn,true)</code>  true=捕获   false=冒泡<br>ie用 <code>dom.attachEvent(&quot;onclick&quot;, fn);</code> 默认是在事件冒泡时执行的,也就是在false的时候执行</p>
<p><strong>阻止事件冒泡</strong>：<code>event.stopPropagation() / window.event.cancelBubble = true (IE浏览器)</code><br><strong>阻止默认事件</strong>：<code>event.preventDefault() / window.event.returnValue = false (IE浏览器)</code><br><strong>两个都阻止</strong>：<code>return false</code></p>
<h3 id="解释JavaScript的同源策略"><a href="#解释JavaScript的同源策略" class="headerlink" title="解释JavaScript的同源策略"></a>解释JavaScript的同源策略</h3><p>同源策略，即拥有相同的协议（protocol），端口（如果指定），主机（域名）的两个页面是属于同一个源。<br>然而在IE中比较特殊，IE中没有将端口号加入同源的条件中，因此上图中端口不同那一项，在IE中是算同源的。<br><code>&lt;script&gt; &lt;img&gt; &lt;iframe&gt;</code>中的src，href都可以任意链接网络资源，是不遵循通源策略的。</p>
<h3 id="跨域形成原因以及解决方案"><a href="#跨域形成原因以及解决方案" class="headerlink" title="跨域形成原因以及解决方案"></a>跨域形成原因以及解决方案</h3><p>跨域是指不同域名之间相互访问。</p>
<p>跨域需要针对浏览器的同源策略来理解，同源策略指的是请求必须是同一个端口，同一个协议，同一个域名，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。</p>
<p>受浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</p>
<p>解决方法：jsonp 、CORS<br>(1) JSONP跨域：利用script脚本允许引用不同域下的js实现的，将回调方法带入服务器，返回结果时回调。<br>(2) 跨域资源共享（CORS）：是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。</p>
<p><strong>CORS与JSONP相比:</strong><br>a、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。<br>b、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。<br>c、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。</p>
<h3 id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"><a href="#请解释JSONP的工作原理，以及它为什么不是真正的AJAX。" class="headerlink" title="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</h3><p>JSONP (JSON with Padding)并不是一种数据格式，而json是一种数据格式；</p>
<p>jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术。</p>
<!-- ## 关于定时器的那些事儿～（偏小白逻辑） -->

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>如果用户持续点击一个按钮，如何只提交一次请求，且不影响后续使用？(其实就是如何节流这个真的问的好多！！！！)</p>
<p><strong>何为节流</strong> 触发函数事件后，短时间间隔内无法连续调用，只有上一次函数执行后，过了规定的时间间隔，才能进行下一次的函数调用，一般用于http请求。</p>
<p><strong>解决原理</strong> 对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conso</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;is run&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> btnUse=<span class="literal">true</span>;</span><br><span class="line"> $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(btnUse)&#123;</span><br><span class="line">         conso();</span><br><span class="line">         btnUse=<span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         btnUse=<span class="literal">true</span>;</span><br><span class="line">     &#125;,<span class="number">1500</span>) <span class="comment">//点击后相隔多长时间可执行</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何防抖？"><a href="#如何防抖？" class="headerlink" title="如何防抖？"></a>如何防抖？</h3><p><strong>何为防抖</strong> 多次触发事件后，事件处理函数只执行一次，并且是在触发操作结束时执行，一般用于scroll事件。</p>
<p><strong>解决原理</strong> 对处理函数进行延时操作，若设定的延时到来之前再次触发事件，则清除上一次的延时操作定时器，重新定时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="built_in">window</span>.onscroll  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//滚动条位置</span></span><br><span class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;滚动条位置：&#x27;</span> + scrollTop);</span><br><span class="line">        timer = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(timeout !== <span class="literal">null</span>)   <span class="built_in">clearTimeout</span>(timeout);        </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(fn, wait);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>2.猜猜如下题目的结果？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s1: &#x27;</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s2: &#x27;</span>, timer.s2), <span class="number">3100</span>);</span><br></pre></td></tr></table></figure>
<p>答案是：<br>s1: 3<br>s2: 0 –&gt;</p>
<h3 id="描述-null、undefined、undeclared-变量的区别"><a href="#描述-null、undefined、undeclared-变量的区别" class="headerlink" title="描述 null、undefined、undeclared 变量的区别"></a>描述 null、undefined、undeclared 变量的区别</h3><p><strong>null</strong> 表示”没有对象”，即该处不应该有值，转为数值时为0。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p>
<p><strong>undefined</strong> 表示”缺少值”，就是此处应该有一个值，但是还没有定义，转为数值时为NaN。典型用法是：<br>（1） 变量被声明了，但没有赋值时，就等于 undefined。<br>（2） 调用函数时，应该提供的参数没有提供，该参数等于 undefined。<br>（3） 对象没有赋值的属性，该属性的值为 undefined。<br>（4） 函数没有返回值时，默认返回 undefined。</p>
<p><strong>undeclared</strong>：js 语法错误，没有申明直接使用，js 无法找到对应的上下文。</p>
<h3 id="全局函数-eval-有什么作用？"><a href="#全局函数-eval-有什么作用？" class="headerlink" title="全局函数 eval() 有什么作用？"></a>全局函数 eval() 有什么作用？</h3><p>eval() 只有一个参数</p>
<ul>
<li>如果传入的参数不是字符串，它直接返回这个参数。</li>
<li>如果参数是字符串，它会把字符串当成 javascript 代码进行编译。</li>
<li>如果编译失败则抛出一个语法错误(syntaxError)异常。</li>
<li>如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回 undefined。</li>
<li>如果字符串抛出一个异常，这个异常将把该调用传递给 eval()。</li>
</ul>
<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步?"></a>同步异步?</h3><p>1、进程同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事</p>
<p>2、异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部分在完成后，通过状态、通知和回调来通知调用者。</p>
<h3 id="原生对象和宿主对象"><a href="#原生对象和宿主对象" class="headerlink" title="原生对象和宿主对象"></a>原生对象和宿主对象</h3><p><strong>原生对象</strong>：是 ECMAScript 规定的对象，所有内置对象都是原生对象，比如 Array、Date、RegExp 等。</p>
<p><strong>宿主对象</strong>：是宿主环境，比如浏览器规定的对象，用于完善是 ECMAScript 的执行环境，比如 Document、Location、Navigator 等。</p>
<h3 id="介绍js有哪些内置对象？"><a href="#介绍js有哪些内置对象？" class="headerlink" title="介绍js有哪些内置对象？"></a>介绍js有哪些内置对象？</h3><p>10种<br>String对象：字符串对象，提供了对字符串进行操作的属性和方法。<br>Array对象：数组对象，提供了数组操作方面的属性和方法。<br>Date对象：日期时间对象，可以获取系统的日期时间信息。<br>Boolean对象：布尔对象，一个布尔变量就是一个布尔对象。(没有可用的属性和方法)<br>Number对象：数值对象。一个数值变量就是一个数值对象。<br>Math对象：数学对象，提供了数学运算方面的属性和方法。<br>Object对象、RegExp(正则表达式)对象、 Error(异常)对象、Function(函数)对象。</p>
<h3 id="页面跳转链接上中文乱码问题"><a href="#页面跳转链接上中文乱码问题" class="headerlink" title="页面跳转链接上中文乱码问题"></a>页面跳转链接上中文乱码问题</h3><p> encodeURIComponent </p>
<h3 id="前端性能优化怎么做"><a href="#前端性能优化怎么做" class="headerlink" title="前端性能优化怎么做"></a>前端性能优化怎么做</h3><p>（1） 减少http请求次数：CSSSprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN 托管，data 缓存，图片服务器。<br>（2） 让ajax可缓存， 前端模板JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 ajax 请求结果，每次操作本地变量，不用请求，减少请求次数<br>（3）用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。<br>（4）当需要设置的样式很多时设置 className 而不是直接操作style。<br>（5）少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。<br>（6） 避免使用 CSSExpression（css表达式)又称Dynamic<br>properties(动态属性)。<br>（7） 图片预加载，将样式表放在顶部（CSS使用<link>标签放在顶部），将脚本放在底部 加上时间戳。（8）合理使用 HTTP 缓存<br>（9） JS去除重复脚本<br>（10） 优化图片、尽量使用PNG<br>（11） 延迟加载组件<br>（12） 减少DOM元素的数量</p>
<h3 id="DOM事件和事件流"><a href="#DOM事件和事件流" class="headerlink" title="DOM事件和事件流"></a>DOM事件和事件流</h3><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h3 id="事件循环-node和浏览器事件循环有何不同"><a href="#事件循环-node和浏览器事件循环有何不同" class="headerlink" title="事件循环   node和浏览器事件循环有何不同"></a>事件循环   node和浏览器事件循环有何不同</h3><h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><h3 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h3><h3 id="vue虚拟dom-amp-diff算法"><a href="#vue虚拟dom-amp-diff算法" class="headerlink" title="vue虚拟dom &amp; diff算法"></a>vue虚拟dom &amp; diff算法</h3><h3 id="虚拟dom的理解"><a href="#虚拟dom的理解" class="headerlink" title="虚拟dom的理解"></a>虚拟dom的理解</h3><h3 id="vue3-解决什么问题"><a href="#vue3-解决什么问题" class="headerlink" title="vue3 解决什么问题"></a>vue3 解决什么问题</h3><h3 id="Vue-为什么不能检测数组和对象的变化-怎么处理-为什么通过索引操作数组不能触发响应式"><a href="#Vue-为什么不能检测数组和对象的变化-怎么处理-为什么通过索引操作数组不能触发响应式" class="headerlink" title="Vue 为什么不能检测数组和对象的变化,怎么处理(为什么通过索引操作数组不能触发响应式)"></a>Vue 为什么不能检测数组和对象的变化,怎么处理(为什么通过索引操作数组不能触发响应式)</h3><h3 id="vue-router-原理"><a href="#vue-router-原理" class="headerlink" title="vue-router 原理"></a>vue-router 原理</h3><h3 id="v-model-实现原理"><a href="#v-model-实现原理" class="headerlink" title="v-model 实现原理"></a>v-model 实现原理</h3><h3 id="介绍一下为什么要有-三次握手，四次挥手"><a href="#介绍一下为什么要有-三次握手，四次挥手" class="headerlink" title="介绍一下为什么要有 三次握手，四次挥手"></a>介绍一下为什么要有 三次握手，四次挥手</h3><h3 id="怎么让数据库查询更快"><a href="#怎么让数据库查询更快" class="headerlink" title="怎么让数据库查询更快"></a>怎么让数据库查询更快</h3><h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><h3 id="CSRF-amp-XSS"><a href="#CSRF-amp-XSS" class="headerlink" title="CSRF &amp; XSS"></a>CSRF &amp; XSS</h3><h3 id="chrome设置小于12px字体"><a href="#chrome设置小于12px字体" class="headerlink" title="chrome设置小于12px字体"></a>chrome设置小于12px字体</h3><h3 id="webpack-tree-shaking"><a href="#webpack-tree-shaking" class="headerlink" title="webpack tree shaking"></a>webpack tree shaking</h3><h3 id="map-amp-set"><a href="#map-amp-set" class="headerlink" title="map &amp; set"></a>map &amp; set</h3><h3 id="前端有哪些技术"><a href="#前端有哪些技术" class="headerlink" title="前端有哪些技术"></a>前端有哪些技术</h3><p>(腾讯面试题,面试官会顺着你说的技术一个一个展开问)</p>
<h3 id="Object-defineProperties-都有那些参数-以及参数解释"><a href="#Object-defineProperties-都有那些参数-以及参数解释" class="headerlink" title="Object.defineProperties 都有那些参数,以及参数解释"></a>Object.defineProperties 都有那些参数,以及参数解释</h3><h3 id="requestAnimation"><a href="#requestAnimation" class="headerlink" title="requestAnimation"></a>requestAnimation</h3><h3 id="让你重新做你做过的项目有什么可以改进的地方"><a href="#让你重新做你做过的项目有什么可以改进的地方" class="headerlink" title="让你重新做你做过的项目有什么可以改进的地方"></a>让你重新做你做过的项目有什么可以改进的地方</h3><h3 id="让一个元素消失的几种做法，有何不同，对子元素的影响"><a href="#让一个元素消失的几种做法，有何不同，对子元素的影响" class="headerlink" title="让一个元素消失的几种做法，有何不同，对子元素的影响"></a>让一个元素消失的几种做法，有何不同，对子元素的影响</h3><p>display:none  disabled  position:absolute left:-200   z-index :-99</p>
<h3 id="如何遍历对象-接下来会问有何不同"><a href="#如何遍历对象-接下来会问有何不同" class="headerlink" title="如何遍历对象(接下来会问有何不同)"></a>如何遍历对象(接下来会问有何不同)</h3><p> for…of 循环，以替代 for…in 和 forEach()</p>
<h3 id="搜索框输入需要注意的点-其实还是在问防抖"><a href="#搜索框输入需要注意的点-其实还是在问防抖" class="headerlink" title="搜索框输入需要注意的点(其实还是在问防抖)"></a>搜索框输入需要注意的点(其实还是在问防抖)</h3><h3 id="原生实现-inserAfter"><a href="#原生实现-inserAfter" class="headerlink" title="原生实现 inserAfter"></a>原生实现 inserAfter</h3><h3 id="页面适配-怎么实现？"><a href="#页面适配-怎么实现？" class="headerlink" title="页面适配  怎么实现？"></a>页面适配  怎么实现？</h3><h3 id="超出文字部分，怎么实现省略号的形式"><a href="#超出文字部分，怎么实现省略号的形式" class="headerlink" title="超出文字部分，怎么实现省略号的形式"></a>超出文字部分，怎么实现省略号的形式</h3><h3 id="HTTP状态码知道哪些？"><a href="#HTTP状态码知道哪些？" class="headerlink" title="HTTP状态码知道哪些？"></a>HTTP状态码知道哪些？</h3><p>100   -   Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200   -  OK  请求成功，正常返回信息<br>201   -  Created 请求成功并且服务器创建了新的资源<br>202   -  Accepted 服务器已接受请求，但尚未处理<br>301   -  Moved Permanently 请求的网页已永久移动到其它URL。<br>302   -  Found 临时性重定向。<br>303   -  See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304   -  Not Modified 自从上次请求后，请求的网页未修改过。<br>400   -  BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401   -  Unauthorized 请求未授权。<br>403   -  Forbidden 禁止访问。<br>404   -  NotFound 找不到如何与 URI 相匹配的资源.   (请求的资源不存在)。<br>500   -  InternalServer Error 最常见的服务器端错误。<br>503  -   ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>
<h3 id="讲讲304缓存的原理"><a href="#讲讲304缓存的原理" class="headerlink" title="讲讲304缓存的原理"></a>讲讲304缓存的原理</h3><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件客户端请求一个页面（A）。<br>服务器返回页面A，并在给A加上一个ETag。<br>客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。</p>
<h3 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="headerlink" title="webpack 和 gulp 的区别"></a>webpack 和 gulp 的区别</h3><h3 id="常见算法-排序洗牌等"><a href="#常见算法-排序洗牌等" class="headerlink" title="常见算法(排序洗牌等)"></a>常见算法(排序洗牌等)</h3><ul>
<li>排序算法(冒泡,快排)</li>
<li>洗牌算法</li>
<li>v1.2.3 v0.3.0 这样的版本号比大小(找简单方法,不要随便写一个循环的版本)</li>
<li>广度优先遍历</li>
<li>用O(n)的复杂度合并两个有序数组</li>
<li>数组生成树形结构</li>
</ul>
<h3 id="字节跳动面试流程"><a href="#字节跳动面试流程" class="headerlink" title="字节跳动面试流程"></a>字节跳动面试流程</h3><p>面试前刷了leetcode和剑指offer，还有牛客网上的面经</p>
<p>HR面试问题</p>
<ol>
<li>你什么时候接触前端的</li>
<li>平时怎么学习 </li>
<li>对未来的规划是什么</li>
<li>你对哪个项目印象深刻，说一下项目的难点 </li>
<li>你对我们公司有什么了解 </li>
<li>能实习多久</li>
</ol>
<p>一面</p>
<ol>
<li>自我介绍，然后问我为什么学习前端</li>
<li>算法：实现36进制转换</li>
<li>简述https原理，以及与http的区别</li>
<li>操作系统中进程和线程怎么通信？</li>
<li>Node中cluster是怎样开启多进程的，并且一个端口可以被多个进程监听吗？</li>
<li>实现原生ajax</li>
<li>vue-router源码</li>
<li>vue原理（手写代码，实现数据劫持）</li>
<li>算法：树的遍历有几种方式，实现下层次遍历</li>
<li>算法：判断对称二叉树</li>
</ol>
<p>二面</p>
<ol>
<li>介绍一下项目中的难点</li>
<li>let const var 有什么区别？</li>
<li>你知道那些http头部？</li>
<li>怎么与服务端保持连接？</li>
<li>http请求跨域问题，你都知道哪些解决跨域的方法</li>
<li>webpack怎么优化</li>
<li>你了解哪些请求方式，分别有哪些作用和不同</li>
<li>你觉得typescript和javascript有什么区别？</li>
<li>typescript你都有用过哪些类型</li>
<li>typescript中的type和interface的区别</li>
<li>react怎么优化</li>
<li>算法题：合并乱序区间</li>
</ol>
<p>三面</p>
<ol>
<li>你了解Node多进程吗？</li>
<li>Node进程中怎么通信</li>
<li>node可以开启多线程吗？</li>
<li>算法题：老师分饼干，每个孩子只能的一块饼干，但每个孩子想要的饼干大小不尽相同，目标是尽量让更多的孩子满意。如孩子的要求是1.3.5.4.2，饼干是1.1，最多能让一个孩子满足。如孩子的要求是10，9，8，7，6，饼干是7，6，5，最多能让2个孩子满足</li>
<li>算法题：给定一个正整数数列a，对于其每个区间，我们都可以计算一个X值，X值的定义如下：对于任意区间，其X值等于区间内最小的那个数乘区间所有树和，现在需要你找出数列a的所有区间中，x值最大的那个区间；如数列a为316452；则X值最大的区间是6，4，5，x=4*(6+4+5)=60</li>
</ol>
<h3 id="半仙君-小公司面试"><a href="#半仙君-小公司面试" class="headerlink" title="半仙君_小公司面试"></a>半仙君_小公司面试</h3><ol>
<li><p><strong>vue使用列表中，用key的作用</strong><br>帮助diff算法确认序号。</p>
</li>
<li><p><strong>diff算法如何用key做一个匹配</strong><br>在vue里diff算法将old列表和new列表在头尾插上序号，分别依次对比头尾，如果四次比较下来没有找到移动的元素在哪就会尝试用key去找，生成以key为键值的map表，在这里面找到（变动的元素）会把对应的元素插到对应的old前面，没有找到的话就直接把新的（？？）放到前面。如果没有key的话就没办法快速找到之前存在的元素直接移过去，导致后面的元素都会产生新的插入。找到移动元素后在map上做标记然后进入下一轮查找。结束的条件是old/new两个序号到一块了，old一致而new不一致说明还有新的元素没有插进去，如果new一致而old不一致说明old这一块是更新后哦不需要的直接删掉即可。</p>
</li>
<li><p><strong>diff算法是如何去做比较的</strong><br>一层一层去做比较，因为在dom修改里会很少涉及跨层次的修改，更多的是同一层次的增删改查，这也是diff算法一个巧妙的地方，直接忽略掉了多个层次的比较，将算法复杂度直接减到O(n)。如果有多个层次的不同的话，直接把下面的替换掉。</p>
</li>
<li><p><strong>能简单描述vue响应式包括模板更新的原理</strong><br>比如写了一个函数和字符串，其实render就相当于new了一个watch的实例，把写的函数放到new的watch实例里，实例会先算一遍value在算的过程中，会把模板里用到的属性方法都给调用一遍。在调之前会把声明的data重新做一个get/set的绑定，在get里面去生成一个dep实例，实例里有一个数组，会保存用到过的watch实例，new watch时跑到了属性就触发了这些属性的get，属性的get里面就会把正在用的watch，这也是vue比较巧妙的地方，会用dep.target去拿当前触发的watch。因为js单线程，按照堆栈去运行，跑到某个watch就把当前watch挂到一个全局变量上，那么在运行watch里的属性触发之前的get，那么肯定全局变量的watch就是当前触发的watch。这样get就能通过全局变量的watch拿到当前触发的watch然后保存一下，这一部分就相当于完成一个个收集，再次改变属性触发set我就能拿到之前数组保存的这些watch然后触发render/value，然后就能用到watch那边去了。</p>
</li>
<li><p><strong>实现响应式系统时用的defineProperty有没有什么缺点</strong><br>性能消耗<br>数组，用get/set是没有办法拦截到这些方法的改变，所以要重写数组的方法做拦截。就好像路由的hash模式直接监听值的改变，history模式如何监听路由改变，也是相当于把方法拦截，url改变后直接触发render<br>网友评论<br>defineProperty是可以拦截数组的。毕竟数组是一种键为index的特殊对象。尤大在issue8000多（8652）的时候说了这个问题。重写数组的方法纯粹是从性能方面考虑</p>
</li>
<li><p><strong>Promise有几种状态，是否可逆，讲一讲你的了解</strong><br>pending后要么走到resolve要么走到reject，不可逆。<br>也是用的观察者模式，new Promise时传入一个构造函数，一开始就执行完这些函数，这些函数里会传入一个resolve和reject，自己去触发之前相当于把待触发的函数扔到队列里，当真正触发了钩子函数再把内部的队列依次执行。<br>.then也是相当于把里面的函数保存到内部队列，如果触发.then的时候判断promise内部状态已经是resolve/reject就会直接把函数触发掉，如果是pending态就会把函数存到数组里然后等resolve触发勾子，依次再把队列刷一遍</p>
</li>
<li><p><strong>Promise这种情况下有什么缺点，&gt;&gt;&gt;结束状态时才会去进行状态改变，这个过程中会有什么缺点</strong><br>无法取消Promise,一旦新建它就会立即执行，无法中途取消。如果要取消的话，要传一个函数的引用进去，看如何给他剔除掉。<br>Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。<br>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
</li>
<li><p><strong>Promise具体实现应用场景</strong><br>new Promise后<br>去调用resolve/reject勾子<br>.then的链式调用以及<br>.all都执行完之后再执行调用以及<br>.race有一个回来了就去调用</p>
</li>
<li><p><strong>Generator有了解吗</strong><br>像async就相当于generator一个语法糖，通过执行到某一步将函数的运行交给另一个线程执行再调回来。</p>
</li>
<li><p><strong>说一下浏览器中eventLoop基本流程</strong><br>js是单线程的，写完了代码相当于有一个主执行栈，这些代码会在执行栈中按次序执行，异步任务像是网络/setTimeout会分别交给浏览器其他线程执行，像setTimeout浏览器会有专门的setTime 的线程去执行，像网络请求浏览器也有network这样的网络线程去执行。<br>这些异步任务在其他的线程都处理完后，就把任务推进任务队列，分为宏任务微任务队列。宏任务像网络/setTimeout，这些线程完成这些任务后把回调推入宏任务队列里，像是promise的或process.nextTick这些回调会被推进微任务理论。主执行栈运行完之后，（js主线程）就会去宏任务找一个执行出来，然后把现有的微任务队列给它清空一次。<br>所以需要注意，如果promise一直往里推很有可能微任务一直执行不完，没办法进入到下一个事件循环里去。</p>
</li>
<li><p><strong>作用域的理解，分为哪几种</strong><br>代码都解析完后，词法分析语法分析都完成后，函数真正去调用时，有一个运行时作用域。<br>像this就是运行时作用域强绑定的一个变量，在不同环境下运行时this会绑定不同的对象</p>
</li>
</ol>
<ol start="12">
<li><strong>使用node开发的场景</strong><br>①做脚手架。用node去写工具，比如模板配套文件生成<br>②中间服务器，在本地生成服务器，转发请求</li>
</ol>
<p>（对①的补充）比如我们创建一个模块，我们可能会生成对应的目录，做词法语法的解析，然后去生成对应的标准化的文件，其他的业务方的同学就直接拿这些模板去写<br>③另外也会用node去做数据流的分析，rxjs，用这个的话会调试困难，所以可以用node生成静态的数据流走向，数据流的依赖图，来帮助分析比较复杂的块<br>（对②的补充）本地一个一个发请求比较困难，就可以在云上用一个node服务器，云上的网络服务器是通畅的，node服务器接收到本地请求后做一连串的自动化事情。处理完后返回结果或是触发下一个流水线操作</p>
<p>网友评论<br>类似vuecli，vue响应式，rander这些种种，包括浏览器执行机制，node执行机制<br>装饰器实现原理，generator实现原理，proxy实现原理，箭头函数实现原理等等，虽然不见得都很难，但是没准备过真的很难在面试中答出来啊，没想过面试官比候选人还喜欢研究八股</p>
<h3 id="解释下为什么接下来这段代码不是IIFE"><a href="#解释下为什么接下来这段代码不是IIFE" class="headerlink" title="解释下为什么接下来这段代码不是IIFE"></a>解释下为什么接下来这段代码不是IIFE</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>以function关键字开头的语句会被解析为函数声明，而函数声明是不允许直接运行的。<br>只有当解析器把这句话解析为函数表达式(<strong>立即调用的函数表达式</strong>)，才能够直接运行，怎么办呢？<br>以运算符 + - () 开头就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code..</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="什么是三元表达式？“三元”表示什么意思？"><a href="#什么是三元表达式？“三元”表示什么意思？" class="headerlink" title="什么是三元表达式？“三元”表示什么意思？"></a>什么是三元表达式？“三元”表示什么意思？</h3><blockquote>
<p>三元表达式：? :。三元–三个操作对象。</p>
</blockquote>
<p>在表达式boolean-exp ? value0 : value1 中，如果“布尔表达式”的结果为true，就计算“value0”，而且这个计算结果也就是操作符最终产生的值。如果“布尔表达式”的结果为false，就计算“value1”，同样，它的结果也就成为了操作符最终产生的值。</p>
<h3 id="JavaScript-里-arguments-究竟是什么？"><a href="#JavaScript-里-arguments-究竟是什么？" class="headerlink" title="JavaScript 里 arguments 究竟是什么？"></a>JavaScript 里 arguments 究竟是什么？</h3><p>Javascrip 中国每个函数都会有一个 Arguments 对象实例 arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用 arguments 的元素。</p>
<p>arguments.length 为函数实参个数，arguments.callee 引用函数自身。</p>
<p>在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，通过使用下标就可以访问相应的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        alert(<span class="built_in">arguments</span>[i]);</span><br><span class="line">        s += <span class="built_in">arguments</span>[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>);<span class="comment">//name,age</span></span><br></pre></td></tr></table></figure>
<p>arguments 虽然有一些数组的性质，但其并非真正的数组，只是一个类数组对象。<br>其并没有数组的很多方法，不能像真正的数组那样调用.jion(),.concat(),.pop()等方法。</p>
<h3 id="什么是”use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是”use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是”use strict”;?使用它的好处和坏处分别是什么？"></a>什么是”use strict”;?使用它的好处和坏处分别是什么？</h3><p>在代码中出现表达式-“use strict”; 意味着代码按照严格模式解析，这种模式使得 Javascript 在更严格的条件下运行。<br>好处：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>坏处：</p>
<ul>
<li>同样的代码，在”严格模式”中，可能会有不一样的运行结果；</li>
<li>一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</li>
</ul>
<h3 id="浏览器页面的构成，分别是-作用是什么？"><a href="#浏览器页面的构成，分别是-作用是什么？" class="headerlink" title="浏览器页面的构成，分别是? 作用是什么？"></a>浏览器页面的构成，分别是? 作用是什么？</h3><p>HTML 结构层  实现页面的结构<br>Css 表示层 渲染页面 完成页面的表现与风格<br>JavaScript 行为层 实现一些客户端的功能与业务</p>
<h3 id="HTML5的优点和缺点"><a href="#HTML5的优点和缺点" class="headerlink" title="HTML5的优点和缺点"></a>HTML5的优点和缺点</h3><p>优点<br>网络标准统一<br>多设备，跨平台<br>即时更新<br>提高可用性和改进用户的友好体验<br>有几个新的标签，这将有助于开发人员定义重要的内容<br>为站点提供更多的多媒体元素（音频和视频）可以很好的替代flash和silverlight<br>抓包<br>移动应用程序与游戏</p>
<p>缺点<br>安全问题<br>性能<br>兼容性问题<br>技术支持<br>完善性</p>
<p>面试的因素<br>技术点 项目经验 面试题 源码（以jQuery入手） </p>
<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p><img src="https://img-blog.csdnimg.cn/45df52363589435d9f16a87592d3ee8c.png" alt="在这里插入图片描述"></p>
<h3 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h3><p><img src="https://img-blog.csdnimg.cn/875d4e057e924b3e8a612d78bb7ddd7e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f7e104d9b8584fb5bd9e3237c1cb5be3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h3><p>parseFloat(‘12.3b’);</p>
<h3 id="如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为12-000-000-11"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如12000000-11转化为12-000-000-11" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为12,000,000.11?"></a>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为12,000,000.11?</h3><p>num.toLocaleString()</p>
<h3 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h3><p>方法一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">  	</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randSort1</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = arr.length;i &lt; len; i++ )&#123;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">var</span> rand = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*len);</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">var</span> temp = arr[rand];</span><br><span class="line">                </span><br><span class="line">    arr[rand] = arr[i];</span><br><span class="line">                </span><br><span class="line">    arr[i] = temp;</span><br><span class="line">  		</span><br><span class="line">&#125;</span><br><span class="line">  		</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">  	</span><br><span class="line">&#125;</span><br><span class="line">  	</span><br><span class="line"><span class="built_in">console</span>.log(randSort1(arr));</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">  	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randSort2</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  		</span><br><span class="line"><span class="keyword">var</span> mixedArray = [];</span><br><span class="line">  		</span><br><span class="line"><span class="keyword">while</span>(arr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  			</span><br><span class="line"><span class="keyword">var</span> randomIndex = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*arr.length);</span><br><span class="line">  	mixedArray.push(arr[randomIndex]);</span><br><span class="line">  						arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  		</span><br><span class="line">&#125;</span><br><span class="line">  		</span><br><span class="line"><span class="keyword">return</span> mixedArray;</span><br><span class="line">  	</span><br><span class="line">&#125;</span><br><span class="line">  	</span><br><span class="line"><span class="built_in">console</span>.log(randSort2(arr));</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(sort带参数的用法，<span class="keyword">return</span>的结果大于<span class="number">0</span>时，移动)  	</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">  	</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  		</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">  	</span><br><span class="line">&#125;)</span><br><span class="line">  	</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="请你谈谈Cookie的弊端"><a href="#请你谈谈Cookie的弊端" class="headerlink" title="请你谈谈Cookie的弊端"></a>请你谈谈Cookie的弊端</h3><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br>第一：每个特定的域名下最多生成20个cookie<br>1）IE6或更低版本最多20个cookie<br>2）IE7和之后的版本最后可以有50个cookie。<br>3）Firefox最多50个cookie<br>4）chrome和Safari没有做硬性限制<br>IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。<br>cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。</p>
<p>优点：极高的扩展性和可用性<br>1）通过良好的编程，控制保存在cookie中的session对象的大小。<br>2）通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>3）只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>4）控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。<br>缺点：<br>1） Cookie 数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.<br>2）安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>3）有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h3><p>1）Web Storage存储容量不受限制，Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，<br>2） cookie还需要指定作用域，不可以跨域调用。<br>3）Web Storage拥有setItem,getItem,removeItem,clear等方法，cookie需要前端开发者自己封装setCookie，getCookie。<br>4）cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ， 而Web Storage仅仅是为了在本地“存储”数据而生</p>
<h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p> 1）cookie数据存放在客户的浏览器上，session数据放在服务器上。<br> 2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗<br> 3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br> 4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br> 5）所以个人建议：<br>考虑到安全应当使用session。<br>考虑到减轻服务器性能方面，应当使用cookie。<br>     将登陆信息等重要信息存放为session<br>其他信息如果需要保留，可以放在cookie中</p>
<h3 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h3><p>1）将时间设为当前时间往前一点。<br>var date = new Date();<br>date.setDate(date.getDate() - 1);//真正的删除<br>setDate()方法用于设置一个月的某一天。<br>2）expires的设置<br> document.cookie= ‘user=’+ encodeURIComponent(‘name’) + ‘;<br>expires = ‘ + newDate(0)<br>7、服务器代理转发时，该如何处理cookie？<br>nginx<br>典型的网络浏览过程中，浏览器如何识别和处理Cookie ?<br>（1）浏览器对于Web服务器应答包头中Cookie的操作步骤：<br>a）从Web服务器的应答包头中提取所有的cookie；<br>b）解析这些cookie的组成部分（名称，值，路径等等）；<br>c）判定主机是否允许设置这些cookie，允许的话，则把这些Cookie存储在本地。<br>（2）浏览器对Web服务器请求包头中所有的Cookie进行筛选的步骤：<br>a）根据请求的URL和本地存储cookie的属性，判断那些Cookie能被发送给Web服务器；<br>b）对于多个cookie，判定发送的顺序；<br>c）把需要发送的Cookie加入到请求HTTP包头中一起发送。</p>
<p>浏览器在接受某一个站点的Cookie的时候，需要检查Cookie的参数domain、path、secure，看是否与当前的站点和URL相符，如果不符的话，就会忽略。另一方面。浏览器在上传Cookie的时候，也会根据当前所访问站点的属性，上传相关的Cookie，而其他的Cookie则不予上传。</p>
<p>Cookie规范对于一个浏览器同时能够存储的Cookie数量作出了规定。<br>（1）总共300 个cookie；<br>（2）每个Cookie 4 K 的存储容量；<br>（3）每一个domain 或者 server 20 个cookie。</p>
<h3 id="如何编写高性能的Javascript？"><a href="#如何编写高性能的Javascript？" class="headerlink" title="如何编写高性能的Javascript？"></a>如何编写高性能的Javascript？</h3><p>（1）使用 DocumentFragment 优化多次 append;<br>（2）通过模板元素 clone，替代 createElement；<br>（3）使用一次 innerHTML 赋值代替构建 dom 元素；<br>（4）使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素；<br>（5）使用 Array 作为 StringBuffer，代替字符串拼接操作；<br>（6）将循环控制量保存到局部变量；<br>（7）顺序无关的遍历时，用 while 替代 for；<br>（8）将条件分支按可能性顺序从高到低排列；<br>（9）使用三目运算符替代条件分支<br>（10）需要不断执行的时候，优先考虑使用 setInterval<br>（11）在同一条件的多条件分支中，使用 switch 优于 if；<br>（8）避免在页面的主体布局中使用 table，table要等其中的内容完全下载之后才会显示，显示比 div + css 布局慢；</p>
<h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h3><p>请求和响应：缓存Ajax、使用CDN、复用TCP、GZIP压缩文件、Cookies<br>减少HTTP请求、多域名分发、避免重定向和404、减少DNS查找等<br>使用外部js和css文件以便缓存、添加<br>Expires头（响应头里，Expires 可以告诉浏览器过期时间）、<br>服务端配置Etag（ETag 则可允许浏览器进行缓存验证）<br>资源：压缩文件、懒加载、预加载<br>合并代码与脚本，Css sprites，初始首屏之外的图片资源按需加载，静态资源延迟加载<br>代码层面的优化<br> JavaScript<br>1）缓存DOM节点查找的结果，减少 IO 读取操作<br>2）避免使用with(with会创建自己的作用域，会增加作用域链长度)<br>3）避免使用 eval和 Function<br>4）减少作用域链查找<br>5）少用全局变量<br>6）字符串拼接  用数组的join方法来代替”+ ”<br>7）用setTimeout来避免页面失去响应<br>8）用hash-table来优化查找<br>9）避免重排、事件委托、内存管理<br>html<br>1）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能<br>2）CSS 放 head，JavaScript 放 body 闭标签前<br>3）脚本延迟加载<br>4）合理使用内联<br>5）减少iframe<br>6）用className来代替在html标签中写Style属性<br>7）避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率<br>8）表格(table)布局改为DIV+CSS<br>css<br>1）避免使用 css 表达式(CSS Expression)，又称动态属性 dynamic properties；<br>2）避免滤镜、Hack<br>移动端性能优化<br>尽量使用css3动画，开启硬件加速。<br>适当使用touch事件代替click事件。<br>避免使用css3渐变阴影效果。<br>可以用transform: translateZ(0)来开启硬件加速。<br>不滥用Float。Float在渲染时计算量比较大，尽量减少使用<br>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。<br>合理使用requestAnimationFrame动画代替setTimeout<br>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发<br>GPU渲染，请合理使用。过渡使用会引发手机过耗电增加<br>PC端的在移动端同样适用</p>
<h3 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h3><p>严格模式主要有以下限制：<br>变量必须声明后再使用<br>函数的参数不能有同名属性，否则报错<br>不能使用with语句<br>不能对只读属性赋值，否则报错<br>不能使用前缀0表示八进制数，否则报错<br>不能删除不可删除的属性，否则报错<br>不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br>eval不会在它的外层作用域引入变量<br>eval和arguments不能被重新赋值<br>arguments不会自动反映函数参数的变化<br>不能使用arguments.callee<br>不能使用arguments.caller<br>禁止this指向全局对象<br>不能使用fn.caller和fn.arguments获取函数调用的堆栈<br>增加了保留字（比如protected、static和interface）<br>设立”严格模式”use strict的目的，主要有以下几个：<br>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript做好铺垫。<br>注：经过测试均不支持严格模式。</p>
<h3 id="谈谈你对重构的理解"><a href="#谈谈你对重构的理解" class="headerlink" title="谈谈你对重构的理解"></a>谈谈你对重构的理解</h3><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说，是在不改变UI的情况下，对网站进行优化，<br>在扩展的同时保持一致的UI。<br>对于传统的网站来说重构通常是：<br>表格(table)布局改为DIV+CSS<br>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)<br>对于移动平台的优化<br>针对于SEO进行优化<br>深层次的网站重构应该考虑的方面<br>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验<br>通常来说对于速度的优化也包含在重构中<br>压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>程序的性能优化(如数据读写)<br>采用CDN来加速资源加载<br>对于JS DOM的优化<br>HTTP服务器的文件缓存</p>
<h3 id="JQuery的源码看过吗？能不能简单概况一下它的实现原理？"><a href="#JQuery的源码看过吗？能不能简单概况一下它的实现原理？" class="headerlink" title="JQuery的源码看过吗？能不能简单概况一下它的实现原理？"></a>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</h3><p><strong>jquery的特点</strong>就是<code>无new构造</code>和<code>链式调用</code>。</p>
<p>如果不需要new的话，就应该在函数体内实例化；且需要一个构造函数来进行构造；然后在每个函数都返回this即可。</p>
<p>jquery的外衣就是这一层闭包；<br>window.jQuery = window.$ = jQuery;<br>将闭包当中定义的jQuery对象导出为全局变量jQuery和$，因此才可以在外部直接使用jQuery和$。</p>
<p>jquery的ready方法的实现原理就是，维护一个函数数组，然后不停的判断DOM是否加载完毕，倘若加载完毕就触发所有数组中的函数；</p>
<h3 id="你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="你觉得jQuery或zepto源码有哪些写的好的地方"></a>你觉得jQuery或zepto源码有哪些写的好的地方</h3><p>(答案仅供参考)<br>Query源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。</p>
<p>jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。<br>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。<br>jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>
<h3 id="请介绍一下JS之事件节流？"><a href="#请介绍一下JS之事件节流？" class="headerlink" title="请介绍一下JS之事件节流？"></a>请介绍一下JS之事件节流？</h3><p>节流：指定时间间隔内只会执行一次任务<br>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化 成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</p>
<h3 id="什么是JS的函数防抖？"><a href="#什么是JS的函数防抖？" class="headerlink" title="什么是JS的函数防抖？"></a>什么是JS的函数防抖？</h3><p>防抖： 任务频繁被触发的情况下，只有任务触发的间隔超过指定时间的时<br>候，任务才会执行<br>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景 是：用户输入，只需再输入完成后做一次输入校验即可。</p>
<p>//没采用防抖动</p>
<h3 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br> 1）实现界面交互<br> 2）提升用户体验<br> 3）有了Node.js，前端可以实现服务端的一些事情<br>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>参与项目，快速高质量完成实现效果图，精确到1px；<br>与团队成员，UI设计，产品经理的沟通；<br>做好的页面结构，页面重构和用户体验；<br>处理hack，兼容、写出优美的代码格式；<br>针对服务器的优化、拥抱最新前端技术</p>
<h3 id="说说你对前端架构师的理解"><a href="#说说你对前端架构师的理解" class="headerlink" title="说说你对前端架构师的理解"></a>说说你对前端架构师的理解</h3><p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；<br>带领团队完成研发工具及平台前端部分的设计、研发和维护；<br>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先<br>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。<br>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、<br>Array、Boolean）进行值复制</p>
<h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.<br>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。<br>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。<br>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left 或margin-right，margin值会加倍。） </p>
<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline; 将其转化为行内属性。(_这个符号只有ie6会识别)<br>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 </p>
<p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发 怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用html5推荐的写法： <code>&lt;doctype html&gt;</code><br>上下margin重合问题 ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和marginbottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
<h3 id="列举IE与其他浏览器不一样的特性？"><a href="#列举IE与其他浏览器不一样的特性？" class="headerlink" title="列举IE与其他浏览器不一样的特性？"></a>列举IE与其他浏览器不一样的特性？</h3><p>IE支持currentStyle，FIrefox使用getComputStyle<br>IE 使用innerText，Firefox使用textContent<br>滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num<br>事件方面：IE：attachEvent：火狐是addEventListener<br>鼠标位置：IE是event.clientX；火狐是event.pageX<br>IE使用event.srcElement；Firefox使用event.target<br>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list<br>style:none<br>CSS圆角：ie7以下不支持圆角 </p>
<h3 id="对BFC规范的理解？"><a href="#对BFC规范的理解？" class="headerlink" title="对BFC规范的理解？"></a>对BFC规范的理解？</h3><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影 响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发 生折叠。<br>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相 互作用。 </p>
<h3 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h3><p>1）去掉或者丢失样式的时候能够让页面呈现出清晰的结构<br>2）有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上 下文和各个关键字的权重；<br>3）方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>4）便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵 循这个标准，可以减少差异化</p>
<h3 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h3><p> FOUC - FlashOf Unstyled Content 文档样式闪烁<br><code> &lt;style type=&quot;text/css&quot;media=&quot;all&quot;&gt;@import&quot;../fouc.css&quot;;&lt;/style&gt;</code><br> 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br> 解决方法简单的出奇，只要在 <code>&lt;head&gt;</code> 之间加入一个 <code>&lt;link&gt;</code> 或者 <code>&lt;script&gt;</code> 元素就可以了。</p>
<h3 id="什么是任务队列？"><a href="#什么是任务队列？" class="headerlink" title="什么是任务队列？"></a>什么是任务队列？</h3><p>任务队列（task queue）主要分两种：<br>1、宏任务（macrotask）：在新标准中叫task<br>（1)主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I/O，ui rendering<br>2、微任务（microtask）：在新标准中叫jobs<br>（1）主要包括：process.nextTick， Promise，MutationObserver（html5新特性）<br>扩展：<br>同步任务：在主线程上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务;<br>异步任务：不进入主线程，而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<h3 id="说说网络分层里七层模型是哪七层"><a href="#说说网络分层里七层模型是哪七层" class="headerlink" title="说说网络分层里七层模型是哪七层"></a>说说网络分层里七层模型是哪七层</h3><p>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）<br>传输层（TCP和UDP）<br>网络层（IP）<br>物理和数据链路层（以太网）<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）<br>各种协议<br>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<h3 id="说说mongoDB和MySQL的区别"><a href="#说说mongoDB和MySQL的区别" class="headerlink" title="说说mongoDB和MySQL的区别"></a>说说mongoDB和MySQL的区别</h3><p>MySQL是传统的关系型数据库，MongoDB则是非关系型数据库<br>mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。<br>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：<br>①弱一致性（最终一致），更能保证用户的访问速度：<br>②文档结构的存储方式，能够更便捷的获取数据。</p>
<h3 id="js-的数据对象有哪些属性值？"><a href="#js-的数据对象有哪些属性值？" class="headerlink" title="js 的数据对象有哪些属性值？"></a>js 的数据对象有哪些属性值？</h3><p>writable：属性的值是否可以修改；<br>configurable：属性的配置是否可以修改；<br>enumerable：属性是否能在for-in循环中遍历出来 或 在Object.keys中列举出来<br>value：属性值</p>
<h3 id="说说你对Promise的理解"><a href="#说说你对Promise的理解" class="headerlink" title="说说你对Promise的理解"></a>说说你对Promise的理解</h3><p>Promise 有三种状态：<br>pending（进行中）、fulfilled（已成功）、rejected（已失败）<br>Promise 是一个对象，从它可以获取异步操作的消息<br>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。<br>Promise 的构造函数<br>构造一个 Promise，最基本的用法如下：</p>
<p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下：<br>promise.then(onFulfilled, onRejected)<br>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是future，onFulfilled对应 resolve, onRejected 对应 reject。</p>
<h3 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><p>移动端页面对于点击事件会有300毫秒的延迟，也就是js捕获click事件的回调函数处理，需要300ms后才生效。<br>移动浏览器为什么会设置300毫秒的等待时间呢？这与双击缩放的方案有关。平时我们有可能已经注意到了，双击缩放，即用手指在屏幕上快速点击两次，可以看到内容或者图片放大，再次双击，浏览器会将网页缩放至原始比例。<br>浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。这段时间就是上面提到的300毫秒延迟。</p>
<p>解决方法：<br>（1）fastclick<br>（2）禁止缩放<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width user-scalable= &#39;no&#39;&quot;&gt;</code><br>  使用这个方法必须完全禁用缩放来达到目的，虽然大部分移动端能解决这个延迟问题，但是部分苹果手机还是不行。<br>（3）绑定ontouchstart事件，加快对事件的响应</p>
<h3 id="如何测试前端代码么-知道BDD-TDD-Unit-Test么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit"><a href="#如何测试前端代码么-知道BDD-TDD-Unit-Test么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit" class="headerlink" title="如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?"></a>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</h3><h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><p>功能检测、userAgent特征检测</p>
<h3 id="什么样的前端代码是好的"><a href="#什么样的前端代码是好的" class="headerlink" title="什么样的前端代码是好的"></a>什么样的前端代码是好的</h3><p>高复用低耦合，这样文件小，好维护，而且好扩展</p>
<h3 id="通用事件绑定-编写一个通用的事件监听函数？"><a href="#通用事件绑定-编写一个通用的事件监听函数？" class="headerlink" title="通用事件绑定/ 编写一个通用的事件监听函数？"></a>通用事件绑定/ 编写一个通用的事件监听函数？</h3><p>1、代理的好处<br>（1）代码简洁<br>（2）减少浏览器内存占用<br>2、事件冒泡<br>事件冒泡的应用：代理 </p>
<h3 id="谈谈你在项目中用过哪些设计模式"><a href="#谈谈你在项目中用过哪些设计模式" class="headerlink" title="谈谈你在项目中用过哪些设计模式"></a>谈谈你在项目中用过哪些设计模式</h3><p>工厂模式：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。<br> 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法搞清楚他们到底是哪个对象的实例。</p>
<p>构造函数模式<br>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：<br>1）构造函数方法没有显示的创建对象 (new Object());<br>2）直接将属性和方法赋值给 this 对象;<br>3）没有 renturn 语句。</p>
<h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><p>CSS3实现圆角（border-radius），阴影（box-shadow），<br>对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器 多背景 rgba<br>在CSS3中唯一引入的伪元素是::selection.<br>媒体查询，多栏布局<br>border-image<br>CSS3中新增了一种盒模型计算方式：box-sizing。<br>盒模型默认的值是content-box, 新增的值是paddingbox和border-box</p>
<h3 id="介绍一下box-sizing属性？"><a href="#介绍一下box-sizing属性？" class="headerlink" title="介绍一下box-sizing属性？"></a>介绍一下box-sizing属性？</h3><p>box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。<br>content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的 宽度/高度决定，设置width/height属性指的是content部分的宽/高<br>border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属 性指的是border + padding + content<br>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺 寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。  </p>
<h3 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h3><p>CSS3新增伪类举例：<br>p:first-of-type选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:last-of-type 选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code>元素。<br>p:only-child 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。<br>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。<br>:enabled :disabled控制表单控件的禁用状态。<br>:checked 单选框或复选框被选中。 </p>
<h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 </p>
<p>拖拽释放(Drag and drop) API<br>语义化更好的内容标签（header,nav,footer,aside,article,section）<br>音频、视频API(audio,video)<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>表单控件，calendar、date、time、email、url、search<br>新的技术webworker, websocket,Geolocation </p>
<p><strong>移除的元素</strong><br>纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>对可用性产生负面影响的元素：frame，frameset，noframes； </p>
<p><strong>支持HTML5新标签</strong>：<br>IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，<br>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 </p>
<p>如何区分： DOCTYPE声明\新增的结构元素\功能元素</p>
<h3 id="CSS中link和-import的区别是？"><a href="#CSS中link和-import的区别是？" class="headerlink" title="CSS中link和@import的区别是？"></a>CSS中link和@import的区别是？</h3><p>(1) link属于HTML标签，而@import是CSS提供的;<br>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;<br>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;<br>(4) link方式的样式的权重 高于@import的权重</p>
<h3 id="position-absolute和float属性的异同"><a href="#position-absolute和float属性的异同" class="headerlink" title="position:absolute和float属性的异同"></a>position:absolute和float属性的异同</h3><p>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。<br>不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 </p>
<h3 id="Flash、Ajax各自的优缺点，在使用中如何取舍？"><a href="#Flash、Ajax各自的优缺点，在使用中如何取舍？" class="headerlink" title="Flash、Ajax各自的优缺点，在使用中如何取舍？"></a>Flash、Ajax各自的优缺点，在使用中如何取舍？</h3><p>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。<br>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</p>
<h3 id="说说你对AMD和Commonjs的理解"><a href="#说说你对AMD和Commonjs的理解" class="headerlink" title="说说你对AMD和Commonjs的理解"></a>说说你对AMD和Commonjs的理解</h3><p>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也<br>就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。<br>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports<br>的属性赋值来达到暴露模块对象的目的。</p>
<h3 id="说说你对MVC和MVVM的理解"><a href="#说说你对MVC和MVVM的理解" class="headerlink" title="说说你对MVC和MVVM的理解"></a>说说你对MVC和MVVM的理解</h3><p>MVC<br>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈<br>所有通信都是单向的。<br>Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。<br>组成部分Model、View、ViewModel<br>View：UI界面<br>ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；<br>Model：数据访问层</p>
<h3 id="document-write-的用法"><a href="#document-write-的用法" class="headerlink" title="document.write()的用法"></a>document.write()的用法</h3><p>document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本<br>创建本窗口或新窗口的内容。<br>document.write()只能重绘整个页面。<br>innerHTML可以重绘页面的一部分<br>编写一个方法求一个字符串的字节长度<br>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a>git fetch和git pull的区别</h3><p>git pull：相当于是从远程获取最新版本并merge到本地<br>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</p>
<h3 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h3><p>attribute是dom元素在文档中作为html标签拥有的属性；<br>property就是dom元素在js中作为对象拥有的属性。<br>所以：<br>对于html的标准属性来说，attribute和property是同步的，是会自动更新的，<br>但是对于自定义的属性来说，他们是不同步的，</p>
<h3 id="用原生JavaScript的实现过什么功能吗？"><a href="#用原生JavaScript的实现过什么功能吗？" class="headerlink" title="用原生JavaScript的实现过什么功能吗？"></a>用原生JavaScript的实现过什么功能吗？</h3><p>轮播图、放大镜、手风琴、鼠标拖拽</p>
<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>-webkit-  Safari &amp; Chrome<br>-moz-  火狐<br>-o- Opera<br>-ms- IE</p>
<h1 id="rem和em的区别？"><a href="#rem和em的区别？" class="headerlink" title="rem和em的区别？"></a>rem和em的区别？</h1><h1 id="怎么自适应？"><a href="#怎么自适应？" class="headerlink" title="怎么自适应？"></a>怎么自适应？</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yanrongdeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/01/10/JS/problem/">http://example.com/2021/01/10/JS/problem/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小燕子的窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/12/JS/array/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Array</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/06/JS/npm/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">npm 命令参数--save，--save-dev，-g 的区别</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yanrongdeng</div><div class="author-info__description">一个爱笑&开朗的妹纸</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://yanrongdeng.github.io/"><i class="fab fa-github"></i><span>个人主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">柯里化函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E5%92%8C-apply-%E3%80%81bind-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">call() 和 apply() 、bind() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-parse-JSON-stringify-obj-%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.1.</span> <span class="toc-text">JSON.parse(JSON.stringify(obj)) 这种方案的弊端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5-URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">一个页面从输入 URL到页面加载显示完成，这个过程中都发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2"><span class="toc-number">5.</span> <span class="toc-text">new 操作符具体干了什么呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2-0-3-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">http2.0 3.0的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0https%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8Ehttp%E7%9A%84%E5%8C%BA%E5%88%AB-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">简述https原理，以及与http的区别 http协议的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">https的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BHttp%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">9.</span> <span class="toc-text">讲一下Http缓存策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99-localStorage-%E5%8A%A0%E4%B8%8A-max-age-%E5%8A%9F%E8%83%BD"><span class="toc-number">10.</span> <span class="toc-text">如何给 localStorage 加上 max-age 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">11.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http%E4%B8%8EHttps%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">Http与Https的基本概念和他们的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.1.</span> <span class="toc-text">http和https的区别:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">HTTPS工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">14.</span> <span class="toc-text">常用的HTTP方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8GET%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8POST"><span class="toc-number">15.</span> <span class="toc-text">GET方法与POST方法的区别,什么时候应该使用GET什么时候应该使用POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%8E%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">HTTP请求报文与响应报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0-1-1-2-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">17.</span> <span class="toc-text">HTTP1.0,1.1,2.0之间的区别和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">18.</span> <span class="toc-text">常见HTTP首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8EHTTPS%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B"><span class="toc-number">19.</span> <span class="toc-text">HTTP的缺点与HTTPS有哪些改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E4%BC%98%E5%8C%96"><span class="toc-number">19.1.</span> <span class="toc-text">HTTP优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HTTPS%E5%AE%89%E5%85%A8"><span class="toc-number">20.</span> <span class="toc-text">为什么HTTPS安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%8C%87%E5%87%BA-onload-%E5%92%8C-ready-%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">请指出 onload 和 ready 两个事件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">什么是事件代理&#x2F;事件委托？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">什么是事件冒泡？什么是事件捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8AJavaScript%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">24.</span> <span class="toc-text">解释JavaScript的同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">25.</span> <span class="toc-text">跨域形成原因以及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8AJSONP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84AJAX%E3%80%82"><span class="toc-number">26.</span> <span class="toc-text">请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">27.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">如何防抖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-null%E3%80%81undefined%E3%80%81undeclared-%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">描述 null、undefined、undeclared 变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0-eval-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">全局函数 eval() 有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="toc-number">31.</span> <span class="toc-text">同步异步?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">32.</span> <span class="toc-text">原生对象和宿主对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8Djs%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">介绍js有哪些内置对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E9%93%BE%E6%8E%A5%E4%B8%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">34.</span> <span class="toc-text">页面跳转链接上中文乱码问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">35.</span> <span class="toc-text">前端性能优化怎么做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">36.</span> <span class="toc-text">DOM事件和事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">37.</span> <span class="toc-text">盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-node%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">38.</span> <span class="toc-text">事件循环   node和浏览器事件循环有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flex"><span class="toc-number">39.</span> <span class="toc-text">Flex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">40.</span> <span class="toc-text">vue响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E8%99%9A%E6%8B%9Fdom-amp-diff%E7%AE%97%E6%B3%95"><span class="toc-number">41.</span> <span class="toc-text">vue虚拟dom &amp; diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">42.</span> <span class="toc-text">虚拟dom的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3-%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">43.</span> <span class="toc-text">vue3 解决什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E4%B8%8D%E8%83%BD%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">44.</span> <span class="toc-text">Vue 为什么不能检测数组和对象的变化,怎么处理(为什么通过索引操作数组不能触发响应式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router-%E5%8E%9F%E7%90%86"><span class="toc-number">45.</span> <span class="toc-text">vue-router 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">46.</span> <span class="toc-text">v-model 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">47.</span> <span class="toc-text">介绍一下为什么要有 三次握手，四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%9B%B4%E5%BF%AB"><span class="toc-number">48.</span> <span class="toc-text">怎么让数据库查询更快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">49.</span> <span class="toc-text">箭头函数和普通函数有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-amp-XSS"><span class="toc-number">50.</span> <span class="toc-text">CSRF &amp; XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chrome%E8%AE%BE%E7%BD%AE%E5%B0%8F%E4%BA%8E12px%E5%AD%97%E4%BD%93"><span class="toc-number">51.</span> <span class="toc-text">chrome设置小于12px字体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-tree-shaking"><span class="toc-number">52.</span> <span class="toc-text">webpack tree shaking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-amp-set"><span class="toc-number">53.</span> <span class="toc-text">map &amp; set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF"><span class="toc-number">54.</span> <span class="toc-text">前端有哪些技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperties-%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%8F%82%E6%95%B0-%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-number">55.</span> <span class="toc-text">Object.defineProperties 都有那些参数,以及参数解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestAnimation"><span class="toc-number">56.</span> <span class="toc-text">requestAnimation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E4%BD%A0%E9%87%8D%E6%96%B0%E5%81%9A%E4%BD%A0%E5%81%9A%E8%BF%87%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">57.</span> <span class="toc-text">让你重新做你做过的项目有什么可以改进的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B6%88%E5%A4%B1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%81%9A%E6%B3%95%EF%BC%8C%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%AF%B9%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">58.</span> <span class="toc-text">让一个元素消失的几种做法，有何不同，对子元素的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%BC%9A%E9%97%AE%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">59.</span> <span class="toc-text">如何遍历对象(接下来会问有何不同)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%A1%86%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9-%E5%85%B6%E5%AE%9E%E8%BF%98%E6%98%AF%E5%9C%A8%E9%97%AE%E9%98%B2%E6%8A%96"><span class="toc-number">60.</span> <span class="toc-text">搜索框输入需要注意的点(其实还是在问防抖)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0-inserAfter"><span class="toc-number">61.</span> <span class="toc-text">原生实现 inserAfter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%80%82%E9%85%8D-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">页面适配  怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%87%BA%E6%96%87%E5%AD%97%E9%83%A8%E5%88%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">63.</span> <span class="toc-text">超出文字部分，怎么实现省略号的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">HTTP状态码知道哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2304%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">65.</span> <span class="toc-text">讲讲304缓存的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-%E5%92%8C-gulp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">66.</span> <span class="toc-text">webpack 和 gulp 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%B4%97%E7%89%8C%E7%AD%89"><span class="toc-number">67.</span> <span class="toc-text">常见算法(排序洗牌等)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-number">68.</span> <span class="toc-text">字节跳动面试流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E4%BB%99%E5%90%9B-%E5%B0%8F%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95"><span class="toc-number">69.</span> <span class="toc-text">半仙君_小公司面试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%98%AFIIFE"><span class="toc-number">70.</span> <span class="toc-text">解释下为什么接下来这段代码不是IIFE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F%E2%80%9C%E4%B8%89%E5%85%83%E2%80%9D%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">什么是三元表达式？“三元”表示什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E9%87%8C-arguments-%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">JavaScript 里 arguments 究竟是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9Duse-strict%E2%80%9D-%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">什么是”use strict”;?使用它的好处和坏处分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">浏览器页面的构成，分别是? 作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">75.</span> <span class="toc-text">HTML5的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">76.</span> <span class="toc-text">递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">77.</span> <span class="toc-text">栈内存和堆内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E4%BE%8B%E5%A6%82%E2%80%9912-3b%E2%80%99"><span class="toc-number">78.</span> <span class="toc-text">如何将字符串转化为数字，例如’12.3b’?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%EF%BC%8C%E5%A6%8212000000-11%E8%BD%AC%E5%8C%96%E4%B8%BA12-000-000-11"><span class="toc-number">79.</span> <span class="toc-text">如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为12,000,000.11?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">80.</span> <span class="toc-text">如何实现数组的随机排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88Cookie%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">81.</span> <span class="toc-text">请你谈谈Cookie的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-storage%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">82.</span> <span class="toc-text">web storage和cookie的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">83.</span> <span class="toc-text">cookie和session的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AAcookie"><span class="toc-number">84.</span> <span class="toc-text">如何删除一个cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84Javascript%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">如何编写高性能的Javascript？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">86.</span> <span class="toc-text">谈谈性能优化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">87.</span> <span class="toc-text">说说严格模式的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%87%8D%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">88.</span> <span class="toc-text">谈谈你对重构的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JQuery%E7%9A%84%E6%BA%90%E7%A0%81%E7%9C%8B%E8%BF%87%E5%90%97%EF%BC%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E7%AE%80%E5%8D%95%E6%A6%82%E5%86%B5%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">89.</span> <span class="toc-text">JQuery的源码看过吗？能不能简单概况一下它的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%A7%89%E5%BE%97jQuery%E6%88%96zepto%E6%BA%90%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%99%E7%9A%84%E5%A5%BD%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">90.</span> <span class="toc-text">你觉得jQuery或zepto源码有哪些写的好的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">91.</span> <span class="toc-text">请介绍一下JS之事件节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJS%E7%9A%84%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="toc-number">92.</span> <span class="toc-text">什么是JS的函数防抖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%9F%E5%AE%83%E7%9A%84%E5%89%8D%E6%99%AF%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">93.</span> <span class="toc-text">对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">94.</span> <span class="toc-text">说说你对前端架构师的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">95.</span> <span class="toc-text">常见兼容性问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BEIE%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">96.</span> <span class="toc-text">列举IE与其他浏览器不一样的特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9BFC%E8%A7%84%E8%8C%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">97.</span> <span class="toc-text">对BFC规范的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">98.</span> <span class="toc-text">说说你对语义化的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-FOUC%EF%BC%88%E6%97%A0%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E9%97%AA%E7%83%81%EF%BC%89%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E6%9D%A5%E9%81%BF%E5%85%8D-FOUC%EF%BC%9F"><span class="toc-number">99.</span> <span class="toc-text">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">100.</span> <span class="toc-text">什么是任务队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E9%87%8C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%93%AA%E4%B8%83%E5%B1%82"><span class="toc-number">101.</span> <span class="toc-text">说说网络分层里七层模型是哪七层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4mongoDB%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">102.</span> <span class="toc-text">说说mongoDB和MySQL的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%9F"><span class="toc-number">103.</span> <span class="toc-text">js 的数据对象有哪些属性值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">104.</span> <span class="toc-text">说说你对Promise的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%EF%BC%9F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6%EF%BC%9F"><span class="toc-number">105.</span> <span class="toc-text">移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88-%E7%9F%A5%E9%81%93BDD-TDD-Unit-Test%E4%B9%88-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88-mocha-sinon-jasmin-qUnit"><span class="toc-number">106.</span> <span class="toc-text">如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">107.</span> <span class="toc-text">检测浏览器版本版本有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A5%BD%E7%9A%84"><span class="toc-number">108.</span> <span class="toc-text">什么样的前端代码是好的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">109.</span> <span class="toc-text">通用事件绑定&#x2F; 编写一个通用的事件监听函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">110.</span> <span class="toc-text">谈谈你在项目中用过哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">111.</span> <span class="toc-text">CSS3有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bbox-sizing%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">112.</span> <span class="toc-text">介绍一下box-sizing属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS3%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">113.</span> <span class="toc-text">CSS3新增伪类有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E7%A7%BB%E9%99%A4%E4%BA%86%E9%82%A3%E4%BA%9B%E5%85%83%E7%B4%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86HTML5%E6%96%B0%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-HTML-%E5%92%8C-HTML5%EF%BC%9F"><span class="toc-number">114.</span> <span class="toc-text">html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E4%B8%ADlink%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">115.</span> <span class="toc-text">CSS中link和@import的区别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position-absolute%E5%92%8Cfloat%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">116.</span> <span class="toc-text">position:absolute和float属性的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flash%E3%80%81Ajax%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8F%96%E8%88%8D%EF%BC%9F"><span class="toc-number">117.</span> <span class="toc-text">Flash、Ajax各自的优缺点，在使用中如何取舍？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9AMD%E5%92%8CCommonjs%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">118.</span> <span class="toc-text">说说你对AMD和Commonjs的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9MVC%E5%92%8CMVVM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">119.</span> <span class="toc-text">说说你对MVC和MVVM的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#document-write-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">120.</span> <span class="toc-text">document.write()的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-fetch%E5%92%8Cgit-pull%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">121.</span> <span class="toc-text">git fetch和git pull的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attribute%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">122.</span> <span class="toc-text">attribute和property的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%8E%9F%E7%94%9FJavaScript%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%E5%90%97%EF%BC%9F"><span class="toc-number">123.</span> <span class="toc-text">用原生JavaScript的实现过什么功能吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number"></span> <span class="toc-text">浏览器内核</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">rem和em的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">怎么自适应？</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/React/" title="React"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"/></a><div class="content"><a class="title" href="/2022/02/15/React/" title="React">React</a><time datetime="2022-02-15T12:16:07.000Z" title="发表于 2022-02-15 20:16:07">2022-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/11/JS/javascript/" title="JavaScript"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/2021/11/11/JS/javascript/" title="JavaScript">JavaScript</a><time datetime="2021-11-11T01:49:41.000Z" title="发表于 2021-11-11 09:49:41">2021-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/JS/es6/" title="ES6"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6"/></a><div class="content"><a class="title" href="/2021/08/31/JS/es6/" title="ES6">ES6</a><time datetime="2021-08-31T12:20:56.000Z" title="发表于 2021-08-31 20:20:56">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/25/tools/git/" title="git"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/2021/06/25/tools/git/" title="git">git</a><time datetime="2021-06-25T12:14:10.000Z" title="发表于 2021-06-25 20:14:10">2021-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/JS/Time/" title="Time格式"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Time格式"/></a><div class="content"><a class="title" href="/2021/06/11/JS/Time/" title="Time格式">Time格式</a><time datetime="2021-06-11T10:18:16.000Z" title="发表于 2021-06-11 18:18:16">2021-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By yanrongdeng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>