<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>vue | 小燕子的窝</title><meta name="keywords" content="Vue"><meta name="author" content="yanrongdeng"><meta name="copyright" content="yanrongdeng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 vueVue 是一套用于构建用户界面的前端框架。    vue 的两个特性数据驱动视图 数据的变化会驱动视图自动更新     双向数据绑定 在网页中，form表单负责采集数据，Ajax负责提交数据   js 数据的变化，会被自动渲染到页面上 页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中   两个特性的底层原理数据驱动视图和双向数据绑定的底层原理是 M">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="http://example.com/2021/04/25/Vue/index.html">
<meta property="og:site_name" content="小燕子的窝">
<meta property="og:description" content="什么是 vueVue 是一套用于构建用户界面的前端框架。    vue 的两个特性数据驱动视图 数据的变化会驱动视图自动更新     双向数据绑定 在网页中，form表单负责采集数据，Ajax负责提交数据   js 数据的变化，会被自动渲染到页面上 页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中   两个特性的底层原理数据驱动视图和双向数据绑定的底层原理是 M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-04-25T12:08:57.000Z">
<meta property="article:modified_time" content="2022-02-23T02:34:48.772Z">
<meta property="article:author" content="yanrongdeng">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/04/25/Vue/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-23 10:34:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归纳</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小燕子的窝</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归纳</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-25T12:08:57.000Z" title="发表于 2021-04-25 20:08:57">2021-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-23T02:34:48.772Z" title="更新于 2022-02-23 10:34:48">2022-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="什么是-vue"><a href="#什么是-vue" class="headerlink" title="什么是 vue"></a>什么是 vue</h1><pre><code>Vue 是一套用于构建用户界面的前端框架。
</code></pre>
<!-- **1） 构建用户界面**
- 用 vue 往 html 页面中填充数据，非常的方便

**2） 框架**
- 框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！
- 要学习 vue，就是在学习 vue 框架中规定的用法！
- vue 的指令、组件(是对UI结构的复用)、路由、vuex、vue 组件库

-->

<h1 id="vue-的两个特性"><a href="#vue-的两个特性" class="headerlink" title="vue 的两个特性"></a>vue 的两个特性</h1><h2 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a>数据驱动视图</h2><ul>
<li>数据的变化<strong>会驱动视图</strong>自动更新<!-- - 好处：程序员只管把数据维护好，那么页面结构会被vue自动渲染出来。 --></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/649ae626e56a4b1cb1032cc2acdc3593.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><blockquote>
<p>在网页中，form表单负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong></p>
</blockquote>
<ul>
<li>js 数据的变化，会被自动渲染到页面上</li>
<li>页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ad075ed5237746839ce0fb3ad9fccb97.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7efa67d00c51453ba39a51c037b64823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="两个特性的底层原理"><a href="#两个特性的底层原理" class="headerlink" title="两个特性的底层原理"></a>两个特性的底层原理</h2><p><strong>数据驱动视图和双向数据绑定的底层原理是 <code>MVVM</code></strong></p>
<blockquote>
<p>① Model 表示页面渲染时所依赖的数据源 (<code>vue 实例中的 data</code>)<br>② View 表示页面渲染的 DOM 结构（视图）(<code>vue 实例中的 el</code>)<br>③ ViewModel 就是 vue 的实例(<code>new Vue()</code>)，是 MVVM 的核心</p>
</blockquote>
<h1 id="vue-的基本使用"><a href="#vue-的基本使用" class="headerlink" title="vue 的基本使用"></a>vue 的基本使用</h1><blockquote>
<p><code>v-cloak</code> 能够解决插值表达式闪烁的问题<br>style中设置<code> [v-cloak]&#123;display：none;&#125;</code></p>
</blockquote>
<p>1）基本使用步骤</p>
<ol>
<li>新建 html 页面</li>
<li>导入 vue.js 的 script 脚本文件 </li>
<li>在页面中声明一个将要被 vue 所控制的 DOM 区域 </li>
<li>创建 vm 实例对象（vue 实例对象）</li>
</ol>
<p>2）基本代码与 MVVM 的对应关系</p>
<ol>
<li>data —— Model 数据源</li>
<li>el —— View 视图 </li>
<li>new Vue() —— ViewModel vue的实例</li>
</ol>
<h1 id="vue-的常用指令"><a href="#vue-的常用指令" class="headerlink" title="vue 的常用指令"></a>vue 的常用指令</h1><h2 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h2><ol>
<li><code>v-text</code> 指令的缺点：会覆盖元素内部原有的内容！</li>
<li><code>&#123;&#123; &#125;&#125;</code> 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！  </li>
<li><code>v-html </code>指令的作用：可以把带有标签的字符串，渲染成真正的HTML内容！</li>
</ol>
<h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><blockquote>
<p>注意：插值表达式<code>&#123;&#123;&#125;&#125;</code>只能用在元素的<strong>内容节点</strong>中，不能用在元素的<strong>属性节点</strong>中</p>
</blockquote>
<ol>
<li>属性绑定的指令 <code>v-bind:</code> ， 简写是 <code>:</code></li>
<li>在使用 <code>v-bind</code> 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">&quot;&#x27;box&#x27; + index&quot;</span>&gt;</span>这是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><code>:class</code> 的使用 <ul>
<li>直接传一个数组 (类名) <code>:class=&quot;[&#39;red&#39;,&#39;thin&#39;]&quot;</code></li>
<li>数组中使用三元表达式  <code>:class=&quot;[&#39;red&#39;,active?&#39;thin&#39;:&#39;&#39;]&quot;</code></li>
<li>在数组中使用对象来代替三元表达式  <code>:class=&quot;[&#39;red&#39;,&#123;&#39;thin&#39;:true&#125;]&quot;</code></li>
<li>在为class绑定对象的时候，对象的属性是类名 <code>:class=&quot;&#123;&#39;red&#39;:false,&#39;thin&#39;:true&#125;&quot;</code></li>
</ul>
</li>
<li><code>:style</code> 的使用<br>一个就直接写，多个就是对象形式</li>
</ol>
<h2 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h2><ol>
<li><p><code>v-on: </code> 简写是 <code>@click</code></p>
</li>
<li><p>语法格式： 如果方法中要修改 data 中的数据，可以通过 this 来访问到</p>
</li>
<li><p><code>$event</code> 的应用场景：如果默认的事件对象e被覆盖了，则可以手动传递一个 $event。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(3,$event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>事件修饰符</p>
<ul>
<li><code>@click.stop </code>  阻止事件冒泡</li>
<li><code>@click.prevent </code> 阻止默认事件</li>
<li><code>@click.capture</code> 实现捕获事件处理机制</li>
<li><code>@click.self </code> 只有点击当前元素，才会触发事件</li>
<li><code>@click.prevent.once</code>  默认事件只触发一次 </li>
</ul>
<p> <strong>Stop 和 self 的区别？</strong></p>
<ul>
<li>stop 阻止冒泡，也就是不触发父级的事件</li>
<li>self 只有点击自身的时候，才会触发事件</li>
</ul>
</li>
<li><p>按键修饰符</p>
<ul>
<li><code>@keyup.esc</code>  Esc 键事件</li>
<li><code>@keyup.enter</code> 回车键事件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h2><p><code>v-model</code>  双向绑定</p>
<ol>
<li>input 输入框 <ul>
<li>type=”radio”</li>
<li>type=”checkbox” ( <code>把后面的 label 的 for 属性设置成 checkbox 的id，label 就可以控制复选框</code> )</li>
<li>type=”xxx”…</li>
</ul>
</li>
<li>textarea</li>
<li>select &gt; option</li>
<li>v-model的修饰符<ul>
<li><code>v-model.trim</code> 自动过滤用户输入的去掉首尾空格</li>
<li><code>v-model.number</code> 自动将用户的输入值转为数值类型</li>
<li><code>v-model.lazy</code> 在”change” 时而非 “input” 时更新</li>
</ul>
</li>
</ol>
<h2 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h2><ol>
<li><code>v-show</code> 的原理是：动态为元素添加或移除 display:none 样式，来实现元素的显示和隐藏<ul>
<li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li>
</ul>
</li>
<li><code>v-if</code> 的原理是：每次动态的创建和销毁 dom 元素，实现元素的显示和隐藏，很消耗性能<ul>
<li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li>
</ul>
</li>
<li><code>v-else-if</code> 必须跟 v-if 一起用，否则无法识别</li>
<li><code>v-else</code>  否则的情况</li>
</ol>
<p><strong>v-if、v-show和 v-visable 的区别？</strong></p>
<ul>
<li>都有隐藏和显示 dom 元素的功能</li>
<li>v-show 类似于 display:none 的用法，只会预编译一次 给元素添加样式</li>
<li>v-if  不停动态的创建和销毁dom元素，很消耗性能 </li>
</ul>
<h2 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h2><p><code>v-for</code> 循环展示 i   普通数组、对象数组、对象、迭代数字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span> = <span class="string">&quot;(item,index) in list&quot;</span>  <span class="attr">:key</span> = <span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<blockquote>
<p>① key 的值只能使用 <code>string</code> 或 <code>number</code> 类型<br>② key 的值<code>必须具有唯一性</code> ( 即：key 的值不能重复 )<br>③ 建议把<code>数据项 id 属性的值</code>作为 key 的值 ( 因为 id 属性的值具有唯一性 )<br>④ 使用<code>index 的值</code>当做 key 的值<code>没有任何意义</code>( 因为 index 的值不具有唯一性 )<br>⑤ 建议使用 v-for 指令时<code>一定要指定key的值</code> ( 既提升性能、又防止列表状态紊乱 )</p>
</blockquote>
<h1 id="filters-过滤器"><a href="#filters-过滤器" class="headerlink" title="filters 过滤器"></a>filters 过滤器</h1><pre><code>过滤器是vue为开发者提供的功能，常用于文本的格式化。
</code></pre>
<p>过滤器可以用在两个地方：<code>插值表达式</code> 和 <code>v-bind 属性绑定</code>。</p>
<blockquote>
<p>① 要定义到 filters 节点下，<strong>本质是一个函数</strong><br>② 在过滤器函数中，<strong>一定要有 return 值</strong><br>③ 在过滤器的形参中，就可以获取到 “管道符” 前面待处理的那个值<br>④ 如果全局过滤器( <code>Vue.filter(&#39;过滤器名称&#39;,function)</code>定义 )和私有过滤器( <code>filters</code>定义 )名字一致，此时按照 “<strong>就近原则</strong>”，调用的是“私有过滤器”</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/29bf602c143a4a33bfb020558e607f52.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="watch-监听器"><a href="#watch-监听器" class="headerlink" title="watch 监听器"></a>watch 监听器</h1><pre><code>监听数据的变化，从而针对数据的变化做特定的操作。
</code></pre>
<h2 id="监听器的格式"><a href="#监听器的格式" class="headerlink" title="监听器的格式"></a>监听器的格式</h2><ol>
<li><p>方法格式的监听器</p>
<blockquote>
<p>① 要定义到 watch 节点下，监听器<strong>本质上是一个函数，无返回值，</strong>要监听哪个数据的变化，就把数据名作为方法名即可<br>② 新值在前，旧值在后<br>③ 可以监听对象的单个属性，用表达式的方式，用单引号 <code>&#39;&#39;</code> 包含表达式</p>
</blockquote>
<ul>
<li>缺点1：无法在刚进入页面的时候，自动触发！！！</li>
<li>缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发监听器！！！</li>
</ul>
</li>
<li><p>对象格式的监听器</p>
<blockquote>
<p>① 监听器的处理函数 handler<br>② immediate 的作用是: 控制监听器是否自动触发一次！ （ 默认值是 false )<br>③ deep 的作用是：深度监听对象的属性变化  （ 默认值是 false )</p>
</blockquote>
<ul>
<li>好处1：可以通过 <strong>immediate</strong> 选项，让监听器首次自动触发一次！！！</li>
<li>好处2：可以通过 <strong>deep</strong> 选项，让监听器深度监听对象中每个属性的变化！！！</li>
</ul>
<p> 代码如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    <span class="function"><span class="title">firstname</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newVal,oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>(newVal)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newVal,oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">username</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal,oldVal)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h1><pre><code>计算属性指的是通过一系列运算之后，最终得到一个属性值。
</code></pre>
<ol>
<li><p><strong>特点</strong><br>① 要定义到 computed 节点下，定义的时候，要被定义为 <strong>“方法格式”</strong><br>② 在使用计算属性的时候，当普通的属性使用即可</p>
</li>
<li><p><strong>好处</strong><br>① 实现了代码的复用<br>② 只要计算属性依赖的数据源变化了，则计算属性会自动重新求值</p>
</li>
</ol>
<p>vue2中，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line"> <span class="function"><span class="title">funllname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="built_in">this</span>.firstname + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue3中，代码如下：<br><code>const plus = compute(() =&gt; &#123;...&#125;)</code></p>
<blockquote>
<p>监听属性和计算属性对比：<br>使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的</p>
</blockquote>
<h1 id="axios-的基本用法"><a href="#axios-的基本用法" class="headerlink" title="axios 的基本用法"></a>axios 的基本用法</h1><pre><code>axios 是一个专注于网络请求的库！
</code></pre>
<p>调用 axios 方法得到的返回值是<code> Promise 对象</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>, <span class="comment">// 请求方式(大写的 GET/POST)</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 请求地址</span></span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;, <span class="comment">// url 中的查询参数  get</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;  <span class="comment">// 请求体参数   post</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&quot;url&quot;</span>,&#123; <span class="attr">params</span>:&#123;<span class="comment">/* GET 查询参数 */</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&quot;url&quot;</span>,&#123; <span class="comment">/* POST 请求体数据 */</span> &#125;)</span><br><span class="line"></span><br><span class="line">axios.delete()</span><br><span class="line"></span><br><span class="line">axios.put()</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<ol>
<li>把 axios 挂载到 vue.prototype 上并配置请求根路径<br> <code>Vue.prototype.$axios = axios</code> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.timeout = <span class="number">10000</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;请求根路径&#x27;</span>;  </span><br><span class="line"><span class="comment">//响应拦截重试</span></span><br><span class="line">axios.defaults.retry = <span class="number">1</span>;  <span class="comment">//重试次数</span></span><br><span class="line">axios.defaults.retryDelay = <span class="number">2000</span>; <span class="comment">//重试时延</span></span><br><span class="line">axios.defaults.shouldRetry = <span class="function"><span class="params">error</span> =&gt;</span> <span class="literal">true</span>; <span class="comment">//重试条件</span></span><br></pre></td></tr></table></figure></li>
<li>把 axios 挂载到 vue原型 上的缺点<br> 无法实现api接口的复用</li>
</ol>
<h1 id="组件的注册与使用"><a href="#组件的注册与使用" class="headerlink" title="组件的注册与使用"></a>组件的注册与使用</h1><p><strong>局部注册</strong> 要定义到 components 节点下<br><strong>注册全局组件</strong> <code>Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)</code></p>
<blockquote>
<ol>
<li>extend 或是省略extend，直接用一个对象:<br> <code>Vue.component(&quot;MyCom1&quot;,Vue.extend(&#123;template:&quot;&lt;h1&gt;这是个h1标签&lt;/h1&gt;&quot;&#125;)) </code> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父传子 props</span></span><br><span class="line">Vue.component(<span class="string">&quot;MyCom1&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">props</span>: [<span class="string">&#x27;todo&#x27;</span>],</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&quot;&lt;h1&gt;&#123;&#123;todo&#125;&#125;&lt;/h1&gt;&quot;</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li>
<li>模板语法( template 放在HTML中，加一个id: )<br> <code>Vue.component(&quot;MyCom2&quot;,&#123;template:&quot;#com4&quot;&#125;)</code></li>
<li>组件化思想 ( .vue文件 )<br> <code>import test from &#39;test.vue&#39;</code><br> <code>Vue.component(&quot;MyCom3&quot;, test)</code></li>
</ol>
</blockquote>
<p><strong>组件使用的三个步骤</strong>：<br>    1. 使用 import 语法导入需要的组件<br>    2. 使用 components 节点注册组件，私有子组件<br>    3. 以标签形式，使用注册的组件</p>
<blockquote>
<p><strong>注意事项：</strong><br>① <code>组件的 data 必须是一个函数，且返回的是一个对象</code><br>② 唯一根节点<br>③ 启用 less 语法 ，在 style 标签中添加 <code>lang=&quot;less&quot;</code><br>④ <code>el:&quot;#app&quot;</code> 等价于 <code>.$mount(&quot;#app&quot;)</code><br>⑤ <code>scoped</code> 组件之间的样式冲突问题  ( 原理：加一个 <code>v-data-一串数字</code> 的属性 )<br>⑥ <code>/deep/</code> 修改子组件中的样式<br>⑦ 以标签的形式，使用注册好的组件时，<code>才会创建组件的实例</code></p>
</blockquote>
<h1 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h1><pre><code>生命周期( Life Cycle )是指一个组件从创建 —&gt; 运行 —&gt; 销毁的整个阶段，强调的是一个时间段。
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/f17ace3eac694531b78a1e3744da22c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建前后、载入前后、更新前后、销毁前后</span></span><br><span class="line"><span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123;&#125;,	<span class="comment">//data、methods、props 未初始化</span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;&#125;,  		<span class="comment">//data、methods、props 初始化好了 (一般发送Ajax请求 )</span></span><br><span class="line"><span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span>&#123;&#125;,	<span class="comment">//页面未渲染</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;&#125;, 		<span class="comment">//页面渲染好了, 才能开始操作dom</span></span><br><span class="line"><span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span>&#123;&#125;,	<span class="comment">//data数据更新了，但页面未改变</span></span><br><span class="line"><span class="function"><span class="title">updated</span>(<span class="params"></span>)</span>&#123;&#125;,		<span class="comment">//页面上已修改</span></span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span>&#123;&#125;,  <span class="comment">//销毁之前，data还可以使用</span></span><br><span class="line"><span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;&#125;,      <span class="comment">//销毁</span></span><br></pre></td></tr></table></figure>
<h1 id="vue-组件通信方式"><a href="#vue-组件通信方式" class="headerlink" title="vue 组件通信方式"></a>vue 组件通信方式</h1><h2 id="props-父→子同步数据"><a href="#props-父→子同步数据" class="headerlink" title="props 父→子同步数据"></a>props 父→子同步数据</h2><pre><code>props 是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大的提高组件的复用性！ 
</code></pre>
<blockquote>
<p>① 父组件通过 <code>v-bind:</code> 属性绑定的形式，把数据传递给子组件<br>② 子组件中，通过 <code>props</code> 接收父组件传递过来的数据<br>③ 是只读的，不能直接修改 props 的值，否则会报错<br>④ (简单)数组形式 <code>props:[&quot;user&quot;,&quot;info&quot;]</code><br>⑤ 组件的 props 对象形式( default 默认值，type 值类型，required 必填项 )<br>⑥ 自定义验证函数 <code>validator(value)</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;Login :user=<span class="string">&quot;userInfo&quot;</span> :info=<span class="string">&quot;info&quot;</span> &gt;&lt;/Login&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件Login</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// props 数组形式</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&quot;user&quot;</span>,<span class="string">&quot;info&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="emit-子→父同步数据"><a href="#emit-子→父同步数据" class="headerlink" title="$emit 子→父同步数据"></a>$emit 子→父同步数据</h2><pre><code>$emit 是组件的自定义事件
</code></pre>
<blockquote>
<p>① 在子组件中调用 <code>this.$emit()</code> 来触发自定义的事件<br>    参数1：字符串，表示自定义事件的名称<br>    参数2：值，要发送给父组件的数据<br>② 在父组件中，通过 <code>v-on:</code> 来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件传递过来的数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 </span></span><br><span class="line">&lt;Login :user=<span class="string">&quot;userInfo&quot;</span>  @countChange=<span class="string">&quot;getCount&quot;</span> &gt;&lt;/Login&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件Login </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// props 对象形式</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">count</span>:<span class="built_in">Number</span>, <span class="comment">//一个类型</span></span><br><span class="line">        <span class="attr">info</span>:[<span class="built_in">String</span>,<span class="built_in">Number</span>], <span class="comment">// 多个类型</span></span><br><span class="line">        <span class="attr">user</span>:&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="built_in">Object</span>, <span class="comment">// 类型</span></span><br><span class="line">            <span class="attr">default</span>: &#123;&#125;, <span class="comment">// 默认值</span></span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span> <span class="comment">// 必传项</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">propD</span>:&#123;</span><br><span class="line">            <span class="comment">// 自定义验证函数</span></span><br><span class="line">            <span class="function"><span class="title">validator</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 返回 true 表示验证通过，false 表示验证失败</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&quot;success&quot;</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;danger&quot;</span>].indexOf(value)!== -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;countChange&#x27;</span>, data) <span class="comment">// 传递数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414104020156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTA0NzE3OQ==,size_16,color_FFFFFF,t_70) -->

<h2 id="EventBus-兄弟同步数据"><a href="#EventBus-兄弟同步数据" class="headerlink" title="EventBus 兄弟同步数据"></a>EventBus 兄弟同步数据</h2><p><img src="https://img-blog.csdnimg.cn/91ca8324757b40b1b7e754527f943cc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/4a1e38fd9d3049fa9b594a3cfe12582a.png" alt="在这里插入图片描述"></p>
<h1 id="ref-获取dom元素和子组件"><a href="#ref-获取dom元素和子组件" class="headerlink" title="ref 获取dom元素和子组件"></a>ref 获取dom元素和子组件</h1><pre><code>ref 用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h3 ref=<span class="string">&quot;name&quot;</span>&gt;标题H3颜色&lt;/h3&gt;</span><br><span class="line"><span class="built_in">this</span>.$refs.name.style.color = <span class="string">&quot;red&quot;</span>  <span class="comment">//获取dom元素</span></span><br><span class="line"></span><br><span class="line">&lt;Login ref=<span class="string">&quot;nameRef&quot;</span>&gt;&lt;/Login&gt;</span><br><span class="line"><span class="built_in">this</span>.$refs.nameRef.login();  <span class="comment">// 通过ref可以获取子组件的data和methods</span></span><br></pre></td></tr></table></figure>

<h1 id="e-target-获取dom元素"><a href="#e-target-获取dom元素" class="headerlink" title="e.target 获取dom元素"></a>e.target 获取dom元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> @change=<span class="string">&quot;checkState&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">checkState</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( e.target.checked )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="this-nextTick-cb-方法"><a href="#this-nextTick-cb-方法" class="headerlink" title="this.$nextTick(cb) 方法"></a>this.$nextTick(cb) 方法</h1><pre><code>this.$nextTick(cb)等组件的DOM更新完成之后，再执行cb回调函数。从而保证cb回调函数可以操作到最新的DOM元素。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;iptRef&quot;</span> /&gt;</span><br><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$refs.iptRef.focus();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="vuex-状态控制"><a href="#vuex-状态控制" class="headerlink" title="vuex 状态控制"></a>vuex 状态控制</h1><h2 id="Vue-与-vuex"><a href="#Vue-与-vuex" class="headerlink" title="Vue 与 vuex"></a>Vue 与 vuex</h2><p>插件 Vue.use(Vuex)  把 Vuex 安装为 Vue 的插件<br>install 会转入vue对象<br>new Vuex.Store({})</p>
<h2 id="Vuex核心"><a href="#Vuex核心" class="headerlink" title="Vuex核心"></a>Vuex核心</h2><ol>
<li><p>state ——&gt; data 保存数据 ( 用于初始化数据 )  是一个方法，返回一个对象<br> 特性： 数据响应</p>
</li>
<li><p>getters ——&gt; 计算属性 （缓存）  是一个对象</p>
</li>
<li><p>mutations ——&gt; 修改数据   是一个对象 ，    <strong>由 commit 触发</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[TYPES](state, data)&#123;</span><br><span class="line">    state.变量名 = data;   <span class="comment">//修改初始值(赋值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>actions ——&gt; 行为   是一个对象<br> 因为 dispatch 不能直接修改 state，所以通过间接的形式，如下：<br> 通过 dispatch 触发 [action]——调用commit——mutations.js中实现commit——修改state<br> 整个导出是一个对象</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> 方法名(&#123; commit, dispatch, state &#125;,params)&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> API.接口(params)  <span class="comment">// 请求接口，返回data</span></span><br><span class="line">    commit(TYPES,data)   <span class="comment">//保存数据</span></span><br><span class="line">    dispatch(另一个方法名，data)  <span class="comment">//触发其他事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>vue组件调用：</strong><br>…rootActions([“方法名”])<br>this.方法名(params)   //触发方法<br>this.$store.commit(TYPES, 数据）// vue组件中，修改state的变量</p>
</li>
<li><p><strong>公共js文件：</strong><br>this.$store.dispatch(“needLogin”, null, { root: true });  // 普通js中调用store的方法</p>
</li>
</ol>
<!-- import state from './state';
import getters from './getters';
import mutations from './mutations';
import actions from './actions';

export default {
    namespaced: true,
    state,
    getters,
    mutations,
    actions
}; -->

<h1 id="component-动态组件"><a href="#component-动态组件" class="headerlink" title="component 动态组件"></a>component 动态组件</h1><pre><code>动态组件指的是动态切换组件的显示与隐藏。
</code></pre>
<ol>
<li><p><code>&lt;component&gt;</code> 标签是 vue 内置的<br> <strong>作用：</strong><code>组件的占位符</code>，专门用来实现动态组件的渲染</p>
</li>
<li><p><code>:is</code> 属性的值，表示<code>要渲染的组件的名字</code>，是组件在 components 节点下的注册名称<br> <strong>作用：</strong>动态绑定变量的值(组件)，可以实现组件的切换，实现展示与隐藏</p>
</li>
<li><p>作用类似于使用<code>v-if  v-else</code>来切换组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;component :is=<span class="string">&quot;compName&quot;</span> &gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.compName=<span class="string">&#x27;Goods&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="keep-alive-标签的使用"><a href="#keep-alive-标签的使用" class="headerlink" title="keep-alive 标签的使用"></a>keep-alive 标签的使用</h1><pre><code>使用&lt;keep-alive&gt;标签保持动态组件的状态。
</code></pre>
<p>原理：通过把内部的组件进行缓存，而不是销毁组件来实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;Goods&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;compName&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="keep-alive-的属性"><a href="#keep-alive-的属性" class="headerlink" title="keep-alive 的属性"></a>keep-alive 的属性</h2><p><code>include</code> —— 字符串或正则表达式。只有名称匹配的组件会被缓存。<br><code>exclude</code> —— 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</p>
<p>但是：不要同时使用 include 和 exclude 这两个属性</p>
<blockquote>
<p>注意：如果组件声明了 name 属性，用 include 和 exclude 这两个属性时，组件名称要对应 name 属性的值，而不是注册名称</p>
</blockquote>
<h2 id="keep-alive-生命周期函数"><a href="#keep-alive-生命周期函数" class="headerlink" title="keep-alive 生命周期函数"></a>keep-alive 生命周期函数</h2><p>当组件<code>被缓存</code>时，会自动触发组件的 <code>deactivated</code> 生命周期函数。<br>当组件<code>被激活</code>时，会自动触发组件的 <code>activated</code> 生命周期函数。</p>
<p>组件第一次创建时，会触发 created 函数，也会触发 activated 函数<br>但是，组件被激活时，会触发 activated 函数，不会触发 created 函数，因为组件没有被重新创建</p>
<p>疑问？我的两个生命周期函数都没有被执行</p>
<h2 id="组件注册名称和声明name时的区别"><a href="#组件注册名称和声明name时的区别" class="headerlink" title="组件注册名称和声明name时的区别"></a>组件注册名称和声明name时的区别</h2><p>如果在声明组件的时候，没有为组件指定 name 名称，则组件的名称默认就是 <code>注册时候的名称</code><br>当提供了 name 属性之后，组件的名称，就是 <code>name属性的值</code></p>
<p>对比：</p>
<ol>
<li>组件注册名称的主要应用场景是：以标签的形式，把注册好的组件，渲染和使用到页面结构中</li>
<li>组件声明name名称的主要应用场景：结合 <code>&lt;keep-alive&gt;</code> 标签实现组件缓存功能，以及调试工具中看到组件的name名称</li>
</ol>
<!-- 允许组件模板递归地调用自身。
注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 -->


<h1 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h1><pre><code>插槽是vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。
</code></pre>
<p>插槽的用法：</p>
<p>（1）动态填充内容，可以使用插槽：<code>&lt;slot&gt;&lt;/slot&gt;</code></p>
<p>（2）插槽的后备内容(默认内容)。</p>
<p>（3）使用插槽：用<code>&lt;template&gt;</code>包含，<code>v-slot:(简写形式 #)</code>指定插槽名字</p>
<p>（4）具名插槽：带有具体名称的插槽，默认为default。</p>
<p>（5）作用域插槽：带有属性数据的插槽。</p>
<p>（6）作用域插槽的解构赋值：使用解构赋值简化数据的接收过程</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认插槽，可省略default --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>想填充的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 具名插槽  后备内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是插槽header的后备内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>=<span class="string">&quot;scope&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; scope.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用域插槽的解构赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="directives-自定义指令"><a href="#directives-自定义指令" class="headerlink" title="directives 自定义指令"></a>directives 自定义指令</h1><ol>
<li>在 <code>directives</code> 节点下，声明定义私有自定义指令</li>
<li>钩子函数 ( v-name 来使用 )<br> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：<br> ① <code>bind</code>：只调用一次，指令第一次绑定到元素时调用。初始化设置。<br> ② <code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br> ③ <code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">bind</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 形参中的 el 是绑定了此指令的、原生的 DOM 对象</span></span><br><span class="line">            el.style.color = binding.value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">        <span class="function"><span class="title">inserted</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">el,binding</span>)</span> &#123;</span><br><span class="line">            el.style.color = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 使用 binding.value 获取指令绑定的值</li>
<li>   <strong>一般情况下，通常把 bind 和 update 写在一起</strong>：函数简写形式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">    <span class="function"><span class="title">color</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        el.style.color = binding.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>   全局自定义指令 <code>Vue.directive(name,func)</code>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;color&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">    el.style.color = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="vue-router-路由"><a href="#vue-router-路由" class="headerlink" title="vue-router 路由"></a>vue-router 路由</h1><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><ol>
<li><p>什么是前端路由(概念)<br> 通俗易懂的概念：Hash 地址与组件之间的<strong>对应关系</strong>。</p>
</li>
<li><p>SPA 与前端路由<br> SPA 指的是一个 web 网站只有唯一的一个 HTML 页面，所有组件的展示与切换都在这唯一的一个页面内完成。<br> 此时，不同组件之间的切换需要通过前端路由来实现。<br> 结论：在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成！</p>
 <!-- SPA 项目中所有的页面展示都是在一个页面中完成的，不同页面组件之间的切换通过前端的路由实现Hash地址与组件之间的对应关系。 --></li>
<li><p>前端路由的工作方式<br> ① 用户<strong>点击了</strong>页面上的<strong>路由链接</strong><br> ② 导致了 <strong>URL 地址栏</strong>中的 <strong>Hash 值</strong>发生了变化<br> ③ <strong>前端路由监听了到 Hash 地址的变化</strong><br> ④ 前端路由把当前 <strong>Hash 地址对应的组件</strong>渲染都浏览器中</p>
</li>
<li><p>手动模拟简易的前端路由<br> ① 使用<code>&lt;component :is=&quot;compName&quot;&gt;</code> 实现组件动态渲染。<br> ② <code>&lt;a href=&quot;#/login&quot;&gt;</code> 链接中添加对应hash。<br> ③ <code>window.onhashchange</code> 监听浏览器地址栏中hash地址的变化。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#123; </span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;#/login&quot;</span>,<span class="attr">components</span>:<span class="string">&quot;Login&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;#/home&quot;</span>,<span class="attr">components</span>:<span class="string">&quot;Home&quot;</span>,</span><br><span class="line">&#125; --&gt;</span><br><span class="line">&lt;!-- 底层原理 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onhashchange=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;监听到了hash地址的变化&quot;</span>,location.hash)</span><br><span class="line">    <span class="keyword">switch</span>(location.hash)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;#/login&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.compName = <span class="string">&quot;Login&quot;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;#/home&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.compName = <span class="string">&quot;Home&quot;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">this</span>.compName = <span class="string">&quot;Login&quot;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由的基本用法"><a href="#路由的基本用法" class="headerlink" title="路由的基本用法"></a>路由的基本用法</h2><ol>
<li><p>安装和配置路由<br> ① 安装 vue-router 包并<strong>导入</strong> <code>npm install vue-router --save</code><br> ② <strong>创建</strong>路由模块（实例）<code>new VueRouter()</code><br> ③ 导入并<strong>挂载</strong>路由模块到 <code>new Vue()</code>实例中的 router 节点下<br> ④ 声明路由链接<code>&lt;router-link to=&quot;xxx&quot;&gt;</code>和 路由切换的占位符 <code>&lt;router-view&gt;</code> </p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.导入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.把 VueRouter 安装为 Vue 的插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建路由实例对象</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 4.路由规则的数组，声明页面和路由的对应关系</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,      <span class="attr">redirect</span>: <span class="string">&#x27;/login&#x27;</span> &#125;, <span class="comment">//重定向</span></span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: Login &#125;</span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;/register/:id/:name&#x27;</span>,<span class="attr">component</span>: Register &#125; <span class="comment">// 动态路由</span></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="comment">// 5.挂载路由模块</span></span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 切换路由 a标签改成router-link  href属性改成to--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tag=&quot;li&quot; 变成li标签，而不是a标签  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;&#123;path:&#x27;/login&#x27;,query:&#123;id:&#x27;10&#x27;,name:&#x27;dyr&#x27;&#125;&#125;&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;li&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/register/20/ywb&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--展示路由组件（占位符） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>redirect</code> 重定向<br> 通过路由规定的 <code>redirect</code> 属性，指定一个新的路由地址，可以实现页面的重定向。</p>
</li>
<li><p>默认情况下, 路径的改变使用的URL的 hash 模式.<br>如果希望使用 HTML5 的 history 模式, 非常简单, 进行如下配置即可:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><code>router-link</code> 补充<br> ① <code>to</code>: 用于指定跳转的路径</p>
<p> ② <code>tag</code>: 可以指定<code>&lt;router-link&gt;</code>之后渲染成什么组件</p>
<pre><code> 比如上面的代码会被渲染成一个`&lt;li&gt;`元素, 而不是`&lt;a&gt;`
 `&lt;router-link to=&#39;/home&#39; tag=&#39;li&#39;&gt;`
</code></pre>
<p> ③ <code>replace</code>: 不会留下 history 记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中<br> ④ <code>active-class</code>: 当<code>&lt;router-link&gt;</code>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active 的 class, 设置 active-class 可以修改默认的名称.</p>
<pre><code> 在进行高亮显示的导航菜单或者底部 tabbar 时, 会使用到该类.
 但是通常不会修改类的属性, 会直接使用默认的 router-link-active 即可.
</code></pre>
</li>
<li><p>命名视图实现经典布局</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定name</span></span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="attr">default</span>:header,</span><br><span class="line">    <span class="attr">left</span>:leftBox,</span><br><span class="line">    <span class="attr">main</span>:mainBox</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由传参的方式"><a href="#路由传参的方式" class="headerlink" title="路由传参的方式"></a>路由传参的方式</h2><p>传递参数主要有两种类型: params和query</p>
<p><strong>params的类型:</strong><br>传递的方式: 在path后面跟上对应的值<br>path配置路由格式: /router/:id<br>在router-link 属性to后跟 /123<br>传递后形成的路径: /router/123, /router/abc</p>
<p><strong>query的类型:</strong> 直接在router-link 属性to后跟查询字符串模式<br>?id=123&amp;name=’sss’不用修改path<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/login?id=<span class="number">10</span>&amp;name=dyr       <span class="built_in">this</span>.$route.query.id</span><br><span class="line">/register/<span class="number">20</span>/ywb            <span class="built_in">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>$route</code> 和<code> $router</code> 是有区别的<br>    $router为VueRouter实例，想要导航到不同URL，则使用router.push方法<br>    $route为当前router跳转对象里面可以获取name、path、query、params等</p>
</blockquote>
<h2 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h2><p><strong>路由懒加载做了什么?</strong><br>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.<br>只有在这个路由被访问到的时候, 才加载对应的组件</p>
<p><strong>懒加载的方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/home/Home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Shopcart = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/shopcart/Shopcart&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><ol>
<li>动态路由的概念<br> 把 Hash 地址可变的部分定义为参数项，从而提高路由规则的复用性。</li>
<li>基本用法<br> 在 vue-router 中使用 <code>/:</code> 来定义路由的参数项。</li>
<li>为路由规则开启 params 传参<br> 可以使用 <code>this.$route.params</code> 对象访问到动态匹配的参数值。<br> 可以在路由规则中开启 params 传参，简化路由参数的获取方式。</li>
<li>拓展 query 和 fullPath<br> query 可以取出查询参数，<br> fullPath 是路由为完整的路径，包括了路径和查询参数。</li>
</ol>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol>
<li>嵌套路由的概念<br> 通过路由实现组件的嵌套展示，叫做嵌套路由。</li>
<li>声明子级路由链接和占位符<br> 使用 router-link 指定 to 属性进行配置，结合 router-view 实现子路由占位</li>
<li>声明嵌套路由的规则<br> 使用 children 属性声明子路由规则，children 为<strong>数组</strong>，<strong>子路由path中不配置 ‘/‘</strong> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&quot;/setting/&quot;</span>,</span><br><span class="line">    <span class="attr">component</span> : setting,</span><br><span class="line">    <span class="attr">redirect</span> : <span class="string">&quot;/setting/personalInfo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span> : [</span><br><span class="line">        &#123;<span class="attr">path</span> : <span class="string">&quot;personalInfo&quot;</span>, <span class="attr">component</span> : personalInfo&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span> : <span class="string">&quot;changePassword&quot;</span>, <span class="attr">component</span> : changePassword&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123; <span class="attr">path</span> : <span class="string">&quot;*&quot;</span>,<span class="attr">redirect</span> : <span class="string">&quot;/setting&quot;</span>&#125;,</span><br></pre></td></tr></table></figure></li>
<li>默认子路由<br> 可以使用父路由中 redirect 实现默认子路由；<br> 还可以将一个子路由path值设为空字符串，则对应的为默认子路由。</li>
</ol>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ol>
<li>声明式导航<br> 在浏览器中，点击链接实现导航的方式，叫做<strong>声明式导航</strong>。<br> 例如:<br> 普通网页中点击<code>&lt;a&gt;</code>链接、vue 项目中点击<code>&lt;router-link&gt;</code>都属于声明式导航</li>
<li>编程式导航<br> 在浏览器中，调用API方法实现导航的方式，叫做<strong>编程式导航</strong>。<br> 例如:<br> 普通网页中调用 location.href 跳转到新页面的方式,属于编程式导航</li>
<li>vue-router 中的编程式导航API<br> 其中最常用的导航API分别是:<br> ① <code>this.$router.push(&#39;hash 地址&quot;)</code> 跳转到指定 hash 地址，并增加一条历史记录<br> ② <code>this.$router.replace(hash 地址)</code> 跳转到指定的 hash 地址，并替换掉当前的历史记录<br> ③ <code>this.$router.go(数值 n)</code> 实现导航历史前进、后退<br> ④ <code>this.$router.back()</code>  在历史记录中，后退到上一个页面<br> ⑤ <code>this.$router.forward()</code> 在历史记录中，前进到下一个页面  </li>
</ol>
<pre><code>history.back() 等价于 history.go(-1)
history.forward() 则等价于 history.go(1)
</code></pre>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p><strong>什么是导航守卫?</strong><br>vue-router提供的导航守卫主要用来监听路由的进入和离开的.</p>
<ol>
<li><p>全局前置守卫<br>使用 router.beforeEach 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...要做的事情</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>确保要调用 next 方法，否则钩子就不会被 resolved。</p>
</li>
<li><p>全局后置守卫<br>不会接受 next 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//不需要next()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>全局解析守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...要做的事情</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>路由独享的守卫<br>你可以在路由配置上直接定义 beforeEnter 守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: Foo,</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>这些守卫与全局前置守卫的方法参数是一样的</p>
</li>
</ol>
<h2 id="控制访问权限"><a href="#控制访问权限" class="headerlink" title="控制访问权限"></a>控制访问权限</h2><h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p><code>Vue.set(obj, obj.length, value);</code>  对数组或对象赋值</p>
<h1 id="全局定义属性或方法"><a href="#全局定义属性或方法" class="headerlink" title="全局定义属性或方法"></a>全局定义属性或方法</h1><p><code>Vue.prototype.$selfName = val</code> 将val设为所有组件都可用 <code>this.$selfName</code></p>
<h1 id="运行环境小提示"><a href="#运行环境小提示" class="headerlink" title="运行环境小提示"></a>运行环境小提示</h1><p><code>Vue.config.productionTip = false;</code> 默认是true </p>
<h1 id="transition-动画"><a href="#transition-动画" class="headerlink" title="transition 动画"></a>transition 动画</h1><h2 id="组件切换动画"><a href="#组件切换动画" class="headerlink" title="组件切换动画"></a>组件切换动画</h2><p>在transition标签上加  <code>mode = &quot; out-in &quot;</code>,定义为先出后进</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">   <span class="selector-class">.v-enter</span>,<span class="selector-class">.v-leave-to</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">150px</span>);</span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.v-enter-active</span>,<span class="selector-class">.v-leave-active</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">transition</span>: all <span class="number">0.8s</span> ease;</span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是一个H3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="vue-resource-异步调用请求"><a href="#vue-resource-异步调用请求" class="headerlink" title="vue-resource 异步调用请求"></a>vue-resource 异步调用请求</h1><p>引入 <code>vue-resource.js</code> 文件<br>Get、post、jsonp</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 发起get请求</span></span><br><span class="line"> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;  <span class="built_in">console</span>.log(result.body) <span class="comment">// 通过 result.body 拿到服务器返回的成功的数据</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="comment">//  通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式</span></span><br><span class="line"> <span class="built_in">this</span>.$http.post(<span class="string">&#x27;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#x27;</span>, &#123;&#125;, &#123; <span class="attr">emulateJSON</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result.body) &#125;)</span><br><span class="line"><span class="comment">// 发起JSONP 请求</span></span><br><span class="line"> <span class="built_in">this</span>.$http.jsonp(<span class="string">&#x27;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#x27;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result.body) &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="vue-devtools-调试工具"><a href="#vue-devtools-调试工具" class="headerlink" title="vue-devtools 调试工具"></a>vue-devtools 调试工具</h1><ol>
<li><p>下载：<code>git clone https://github.com/vuejs/vue-devtools</code></p>
</li>
<li><p>新版的vue-devtools并不是用npm安装，而是用yarn</p>
<blockquote>
<p>当你的node项目需要yarn支持时，应该先安装它，然后添加环境变量，再进行npm run build动作</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line">node -v <span class="comment">#检测node版本（此条命令非必要）</span></span><br><span class="line">npm -v <span class="comment">#检测npm版本（此条命令非必要）</span></span><br><span class="line">npm config set registry https:<span class="regexp">//</span>registry.npm.taobao.org <span class="comment">#把npm源设置为淘宝源（这个你懂的）</span></span><br><span class="line">npm config get registry <span class="comment">#检测npm是否切换成功（此条命令非必要）</span></span><br><span class="line">export PATH=<span class="variable">$PATH</span>:<span class="regexp">/usr/</span>local<span class="regexp">/nodejs/</span>node-v10.<span class="number">16.0</span>-linux-x64<span class="regexp">/bin/</span></span><br><span class="line"></span><br><span class="line">cd vue-devtools</span><br><span class="line">npm install <span class="comment">#安装项目中的依赖</span></span><br><span class="line">yarn upgrade caniuse-lite browserslist</span><br></pre></td></tr></table></figure></li>
<li><p>修改 manifest.json 文件里的 “persistent”:false 改成 true<br>路径：<code>vue-devtools/packages/shell-chrome/manifest.json</code></p>
</li>
<li><p>编译代码： <code>npm run build</code></p>
</li>
<li><p>打开 chrome 的扩展程序，开发者模式，加载已经解压的扩展程序，放入 shell &gt; chrome<br>Chrome浏览器 &gt;  更多程序 &gt; 拓展程序<br>点击加载已解压程序按钮, 选择 vue-devtools &gt; shells &gt; chrome 放入, 安装成功如下图<br><img src="https://img-blog.csdnimg.cn/b578449e5aad491c88641acc52c0cb93.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTA0NzE3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>vue-devtools 使用<br>vue 项目, 打开 f12 , 选择 vue 就可以使用了.<br>vue 是数据驱动的, 这样就能看到对应数据了, 方便我们进行调试</p>
<blockquote>
<p><strong>温情提示</strong>: </p>
<blockquote>
<p>1.vue 必须引入开发版, 使用 min 压缩版是不能使用 devtools 进行调试的<br>2.安装后, 需要关闭浏览器, 再重新打开, 才能使用</p>
</blockquote>
</blockquote>
</li>
</ol>
<h1 id="vue-cli-的安装和使用"><a href="#vue-cli-的安装和使用" class="headerlink" title="vue-cli 的安装和使用"></a>vue-cli 的安装和使用</h1><h2 id="什么是-vue-cli"><a href="#什么是-vue-cli" class="headerlink" title="什么是 vue-cli"></a>什么是 vue-cli</h2><p><code>vue-cli 是 vue.js 开发的标准工具</code>。它简化了程序员基于 webpack 创建工程化的 vue 项目的过程</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>方式一：<br>1、全局安装 <a href="mailto:&#x76;&#x75;&#101;&#x2d;&#x63;&#108;&#105;&#64;&#x33;&#46;&#x78;&#46;&#120;">&#x76;&#x75;&#101;&#x2d;&#x63;&#108;&#105;&#64;&#x33;&#46;&#x78;&#46;&#120;</a>：<code>npm install --global vue-cli</code><br>2、新建项目：<code>vue create hello-world</code><br>3、进入项目目录：<code>cd hello-world</code><br>4、安装依赖：<code>npm install</code><br>5、启动服务：<code>npm run serve</code></p>
<p>方式二：<br>1、全局安装 <a href="mailto:&#118;&#x75;&#x65;&#45;&#99;&#108;&#105;&#x40;&#x32;&#46;&#120;&#x2e;&#x78;">&#118;&#x75;&#x65;&#45;&#99;&#108;&#105;&#x40;&#x32;&#46;&#120;&#x2e;&#x78;</a>：<code>npm install --global vue-cli</code><br>2、新建项目：<code>vue init webpack my-project</code><br>3、进入项目目录：<code>cd my-project</code><br>4、安装依赖：<code>npm install</code><br>5、启动服务：<code>npm run dev</code></p>
<h2 id="vue-create-和vue-init-webpack的区别"><a href="#vue-create-和vue-init-webpack的区别" class="headerlink" title="vue create 和vue init webpack的区别"></a>vue create 和vue init webpack的区别</h2><p>都是因为 <code>vue-cli</code> 不同版本号，初始化方式不同</p>
<p><code>vue init webpack</code> 是 <strong>vue-cli2.x</strong> 的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。</p>
<p><code>vue create</code> 是 <strong>vue-cli3.x</strong> 的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是 vue-cli3 的项目，与 cue-cli2 项目结构不同，配置方法不同，具体配置方法参考<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/">官方文档</a>。</p>
<p>vue-cli3.x 取消掉了config目录、build目录、static目录，还有最重要的一点，3.0的安装项目时自动下载node-model，vue.config.js也没了，需要手动添加。</p>
<p>vue-cli2.x 项目向 3.x 迁移只需要把 static 目录复制到 public 目录下，老项目的 src 目录覆盖 3.x 的 src 目录( 如果修改了配置，可以查看文档，用cli3的方法进行配置 )</p>
<h1 id="Vant-组件库"><a href="#Vant-组件库" class="headerlink" title="Vant 组件库"></a>Vant 组件库</h1><p><a target="_blank" rel="noopener" href="https://vant-contrib.gitee.io/vant/#/zh-CN/">中文文档</a></p>
<p>1.学习使用vant-ui里的Navbar组件的使用</p>
<h1 id="上拉加载-amp-下拉刷新"><a href="#上拉加载-amp-下拉刷新" class="headerlink" title="上拉加载 &amp; 下拉刷新"></a>上拉加载 &amp; 下拉刷新</h1><h1 id="Vant-主题定制"><a href="#Vant-主题定制" class="headerlink" title="Vant 主题定制"></a>Vant 主题定制</h1><!-- # 创建vue项目

方法一：vue create 项目名

# 创建完成后，可以通过命令打开图形化界面
vue ui 

方法三：npm init vite-APP 项目名 -->

<h1 id="vue-实例"><a href="#vue-实例" class="headerlink" title="vue 实例"></a>vue 实例</h1><p><a target="_blank" rel="noopener" href="https://yanrongdeng.github.io/2016/02/25/html/vue%E5%AE%9E%E7%8E%B0%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/">用vue实现一个表的增删改查</a></p>
<h1 id="2-x-学习结构图"><a href="#2-x-学习结构图" class="headerlink" title="2.x 学习结构图"></a>2.x 学习结构图</h1><p><img src="https://img-blog.csdnimg.cn/f07e6473a74248c89a80e8cfd3e7949f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTA0NzE3OQ==,size_16,color_FFFFFF,t_70" alt="学习vue2.0结构图"></p>
<h1 id="2-x-数据劫持"><a href="#2-x-数据劫持" class="headerlink" title="2.x 数据劫持"></a>2.x 数据劫持</h1><p>vue 实现响应式 基于 Object.defineProperty() 的 get set  数据劫持<br>defineReactive()  //提供一个闭包环境，避免环境污染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineRactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.definePorperty(obj,key,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">defineRactive(obj,<span class="string">&quot;a&quot;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj.a)</span><br><span class="line"></span><br><span class="line">Observe类 本质 核心功能：  正常 obj -- 属性 加工 响应式 obj</span><br><span class="line">observe(obj) 由此触发，所有的开始 ——&gt;  判断obj身上是否有__ob__   ——&gt;   <span class="keyword">new</span> Observe() </span><br><span class="line"> </span><br><span class="line"><span class="comment">//__ob__ 唯一的标识  存在不需要再次劫持</span></span><br><span class="line"><span class="comment">// 设置 __ob__ 不能被枚举</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/3b9628493c094a759d1504c2097da0c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTA0NzE3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b9d10e7c0f3e4859be5b569b42540290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTA0NzE3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!-- 前端9期-day1 p190-p210
3.1、初识Express
3.1.1、Express简介
1、什么是Express
    官方给出的概念：Express是基于Node.js平台，快速、开放、极简的Web开发框架。
    通俗的理解：Express的作用和 Node.js内置的http模块类似，是专门用来创建 Web 服务器的。
    Express 的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法。
    Express 的中文官网： http://www.expressjs.com.cn/（建议下载4.17.1版本）
2、进一步理解Express
1、思考：不使用 Express 能否创建 Web服务器？
    答案：能，使用Node.js提供的原生http模块即可。
2、思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？
    答案：http内置模块用起来很复杂，开发效率低；Express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率。
3、思考：http内置模块与Express是什么关系？
    答案：类似于浏览器中Web API和jQuery的关系。后者是基于前者进一步封装出来的。
3、Express能做什么
对于前端程序员来说，最常见的两种服务器，分别是：
     Web 网站服务器：专门对外提供 Web 网页资源的服务器。
     API 接口服务器：专门对外提供 API 接口的服务器。
使用 Express，我们可以方便、快速的创建Web网站的服务器或API接口的服务器。
-->

<!-- # v-pre
# v-once -->


<h1 id="vue3-X"><a href="#vue3-X" class="headerlink" title="vue3.X"></a>vue3.X</h1><p>新增的功能例如：<br><code>组合式API</code>、多根节点组件、更好的TypeScript支持等</p>
<p>废弃的旧功能如下：<br><code>过滤器</code>、不在支持$on,$off 和 $once 实例方法等</p>
<h1 id="vite-的基本使用"><a href="#vite-的基本使用" class="headerlink" title="vite 的基本使用"></a>vite 的基本使用</h1><p>vite 只适用于 <strong>vue3.x</strong> 的工程化项目</p>
<ol>
<li>创建项目：<code>npm init vite-app 项目名称</code></li>
<li>进入项目：<code>cd 项目名称</code></li>
<li>安装依赖：<code>npm install</code></li>
<li>启动项目：<code>npm run dev</code></li>
</ol>
<h2 id="vue-cli-和-vite-对比"><a href="#vue-cli-和-vite-对比" class="headerlink" title="vue-cli 和 vite 对比"></a>vue-cli 和 vite 对比</h2><p><img src="https://img-blog.csdnimg.cn/78693123ee854c45a0c1ec76ce02f57c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="vue3-X-组件之间的数据共享"><a href="#vue3-X-组件之间的数据共享" class="headerlink" title="vue3.X 组件之间的数据共享"></a>vue3.X 组件之间的数据共享</h1><h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><pre><code>props属性绑定
</code></pre>
<h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><pre><code>事件绑定
</code></pre>
<ol>
<li>声明自定义事件 <code>emits[名称]</code>  (vue3新增)</li>
<li>触发自定义事件 <code>this.$emit(名称)</code></li>
<li>监听自定义事件 <code>@名称</code></li>
</ol>
<h2 id="父子双向同步"><a href="#父子双向同步" class="headerlink" title="父子双向同步"></a>父子双向同步</h2><pre><code>组件上的v-model  实现组件内外的数据同步
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/4d1ce6f8ebf944c0901fa385fddfb765.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件引用子组件</span></span><br><span class="line">&lt;Couter v-model:count=<span class="string">&quot;count&quot;</span>&gt;&lt;/Couter&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;count&#x27;</span>],</span><br><span class="line">  <span class="comment">// 注意  用的是英文的冒号:  并且变量名保持一致</span></span><br><span class="line">  <span class="attr">emits</span>:[<span class="string">&#x27;update:count&#x27;</span>],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:count&#x27;</span>,<span class="built_in">this</span>.count+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟关系"><a href="#兄弟关系" class="headerlink" title="兄弟关系"></a>兄弟关系</h2><pre><code>eventBus
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/bf080e32721941feb31ecfa34c39e0cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54eV5a2Q6bG855qE55y85rOq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="后代关系"><a href="#后代关系" class="headerlink" title="后代关系"></a>后代关系</h2><pre><code>provide &amp; inject
computed(()=&gt;&#123;&#125;)
</code></pre>
<h2 id="全局数据共享"><a href="#全局数据共享" class="headerlink" title="全局数据共享"></a>全局数据共享</h2><pre><code>vuex
</code></pre>
<h1 id="vue3-x-中全局配置axios"><a href="#vue3-x-中全局配置axios" class="headerlink" title="vue3.x 中全局配置axios"></a>vue3.x 中全局配置axios</h1><p><code>axios.defaults.baseURL=&#39;&#39;</code><br><code>app.config.globalProperties.$axios = axios;</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yanrongdeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/25/Vue/">http://example.com/2021/04/25/Vue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小燕子的窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/11/JS/Time/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Time格式</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/28/webpack/webpack4/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack4 快速入门指南</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yanrongdeng</div><div class="author-info__description">一个爱笑&开朗的妹纸</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://yanrongdeng.github.io/"><i class="fab fa-github"></i><span>个人主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vue"><span class="toc-number">1.</span> <span class="toc-text">什么是 vue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">vue 的两个特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">数据驱动视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.</span> <span class="toc-text">双向数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">两个特性的底层原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">vue 的基本使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">vue 的常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">内容渲染指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">属性绑定指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">事件绑定指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.</span> <span class="toc-text">双向绑定指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.</span> <span class="toc-text">条件渲染指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.</span> <span class="toc-text">列表渲染指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#filters-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">filters 过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#watch-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">watch 监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">监听器的格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#computed-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">computed 计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#axios-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">axios 的基本用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">组件的注册与使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.</span> <span class="toc-text">vue 的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">vue 组件通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#props-%E7%88%B6%E2%86%92%E5%AD%90%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">11.1.</span> <span class="toc-text">props 父→子同步数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#emit-%E5%AD%90%E2%86%92%E7%88%B6%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">11.2.</span> <span class="toc-text">$emit 子→父同步数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus-%E5%85%84%E5%BC%9F%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">11.3.</span> <span class="toc-text">EventBus 兄弟同步数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ref-%E8%8E%B7%E5%8F%96dom%E5%85%83%E7%B4%A0%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">ref 获取dom元素和子组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#e-target-%E8%8E%B7%E5%8F%96dom%E5%85%83%E7%B4%A0"><span class="toc-number">13.</span> <span class="toc-text">e.target 获取dom元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this-nextTick-cb-%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">this.$nextTick(cb) 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex-%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">vuex 状态控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%8E-vuex"><span class="toc-number">15.1.</span> <span class="toc-text">Vue 与 vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E6%A0%B8%E5%BF%83"><span class="toc-number">15.2.</span> <span class="toc-text">Vuex核心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#component-%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">16.</span> <span class="toc-text">component 动态组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#keep-alive-%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text">keep-alive 标签的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">17.1.</span> <span class="toc-text">keep-alive 的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.</span> <span class="toc-text">keep-alive 生命周期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%E5%90%8D%E7%A7%B0%E5%92%8C%E5%A3%B0%E6%98%8Ename%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.3.</span> <span class="toc-text">组件注册名称和声明name时的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#slot-%E6%8F%92%E6%A7%BD"><span class="toc-number">18.</span> <span class="toc-text">slot 插槽</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#directives-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">19.</span> <span class="toc-text">directives 自定义指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-router-%E8%B7%AF%E7%94%B1"><span class="toc-number">20.</span> <span class="toc-text">vue-router 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1"><span class="toc-number">20.1.</span> <span class="toc-text">前端路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">20.2.</span> <span class="toc-text">路由的基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">20.3.</span> <span class="toc-text">路由传参的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">20.4.</span> <span class="toc-text">路由的懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">20.5.</span> <span class="toc-text">动态路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1"><span class="toc-number">20.6.</span> <span class="toc-text">嵌套路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">20.7.</span> <span class="toc-text">导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">20.8.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">20.9.</span> <span class="toc-text">控制访问权限</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">21.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">全局定义属性或方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%B0%8F%E6%8F%90%E7%A4%BA"><span class="toc-number">23.</span> <span class="toc-text">运行环境小提示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#transition-%E5%8A%A8%E7%94%BB"><span class="toc-number">24.</span> <span class="toc-text">transition 动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB"><span class="toc-number">24.1.</span> <span class="toc-text">组件切换动画</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-resource-%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82"><span class="toc-number">25.</span> <span class="toc-text">vue-resource 异步调用请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-devtools-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">26.</span> <span class="toc-text">vue-devtools 调试工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-cli-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">27.</span> <span class="toc-text">vue-cli 的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vue-cli"><span class="toc-number">27.1.</span> <span class="toc-text">什么是 vue-cli</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">27.2.</span> <span class="toc-text">安装和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-create-%E5%92%8Cvue-init-webpack%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.3.</span> <span class="toc-text">vue create 和vue init webpack的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vant-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-number">28.</span> <span class="toc-text">Vant 组件库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD-amp-%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number">29.</span> <span class="toc-text">上拉加载 &amp; 下拉刷新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vant-%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6"><span class="toc-number">30.</span> <span class="toc-text">Vant 主题定制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E5%AE%9E%E4%BE%8B"><span class="toc-number">31.</span> <span class="toc-text">vue 实例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-x-%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">32.</span> <span class="toc-text">2.x 学习结构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-x-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81"><span class="toc-number">33.</span> <span class="toc-text">2.x 数据劫持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3-X"><span class="toc-number">34.</span> <span class="toc-text">vue3.X</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vite-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">35.</span> <span class="toc-text">vite 的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli-%E5%92%8C-vite-%E5%AF%B9%E6%AF%94"><span class="toc-number">35.1.</span> <span class="toc-text">vue-cli 和 vite 对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3-X-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">36.</span> <span class="toc-text">vue3.X 组件之间的数据共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E4%BC%A0%E5%AD%90"><span class="toc-number">36.1.</span> <span class="toc-text">父传子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E4%BC%A0%E7%88%B6"><span class="toc-number">36.2.</span> <span class="toc-text">子传父</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%8F%8C%E5%90%91%E5%90%8C%E6%AD%A5"><span class="toc-number">36.3.</span> <span class="toc-text">父子双向同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E5%85%B3%E7%B3%BB"><span class="toc-number">36.4.</span> <span class="toc-text">兄弟关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E4%BB%A3%E5%85%B3%E7%B3%BB"><span class="toc-number">36.5.</span> <span class="toc-text">后代关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">36.6.</span> <span class="toc-text">全局数据共享</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3-x-%E4%B8%AD%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AEaxios"><span class="toc-number">37.</span> <span class="toc-text">vue3.x 中全局配置axios</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/React/" title="React"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"/></a><div class="content"><a class="title" href="/2022/02/15/React/" title="React">React</a><time datetime="2022-02-15T12:16:07.000Z" title="发表于 2022-02-15 20:16:07">2022-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/11/JS/javascript/" title="JavaScript"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/2021/11/11/JS/javascript/" title="JavaScript">JavaScript</a><time datetime="2021-11-11T01:49:41.000Z" title="发表于 2021-11-11 09:49:41">2021-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/JS/es6/" title="ES6"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6"/></a><div class="content"><a class="title" href="/2021/08/31/JS/es6/" title="ES6">ES6</a><time datetime="2021-08-31T12:20:56.000Z" title="发表于 2021-08-31 20:20:56">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/25/tools/git/" title="git"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/2021/06/25/tools/git/" title="git">git</a><time datetime="2021-06-25T12:14:10.000Z" title="发表于 2021-06-25 20:14:10">2021-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/JS/Time/" title="Time格式"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Time格式"/></a><div class="content"><a class="title" href="/2021/06/11/JS/Time/" title="Time格式">Time格式</a><time datetime="2021-06-11T10:18:16.000Z" title="发表于 2021-06-11 18:18:16">2021-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By yanrongdeng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>